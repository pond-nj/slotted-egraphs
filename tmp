   Compiling slotted-egraphs v0.0.36 (/home/pondnj/chc/project/slotted-egraphs)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.50s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-7db37e3e129514c0)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-9a9d60ae6aa2b312)

running 1 test
[entry::chc::tst] p_compose = (compose <(new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0)>) (true) <>)>) (compose <(new (pred <(var $1)>) (true) <>)>)>)>) (compose <(new (pred <(var $0)>) (true) <>)>)>) (new (pred <(var $0) (var $1)>) (true) <>)>)
[slotted_egraphs::parse] from (compose <(new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0)>) (true) <>)>) (compose <(new (pred <(var $1)>) (true) <>)>)>)>) (compose <(new (pred <(var $0)>) (true) <>)>)>) (new (pred <(var $0) (var $1)>) (true) <>)>)
[slotted_egraphs::parse] to tokens [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen]
[entry::chc] calling make on Var($f0)
[entry::chc] result {$f0: Unknown}
[slotted_egraphs::egraph::add] classes insert id0
[slotted_egraphs::egraph::add] add to id0 Var($0)
[slotted_egraphs::egraph::add] remove from id0 Var($0)
[slotted_egraphs::egraph::add] add to id0 Var($0)
[entry::chc] calling make on Var($0)
[entry::chc] exists in egraph
[entry::chc] result {$f0: Unknown}
[entry::chc] calling merge to id0
[entry::chc] eclassSlots {$f0}
[entry::chc] result varTypes {$f0: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id0 <-> (var $0)
[slotted_egraphs::egraph::add] add_syn_expr: id0 <-> (var $1)
[entry::chc] calling make on PredSyntax([id0: ($f0 -> $f1), id0: ($f0 -> $f2)])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f1, $f2}
[entry::chc] childId : id0, mapToS : $f0
[entry::chc] adding $f1 to varTypes
[entry::chc] childId : id0, mapToS : $f0
[entry::chc] adding $f2 to varTypes
[entry::chc] aggregateVarType for PredSyntax([id0: ($f0 -> $f1), id0: ($f0 -> $f2)])
[entry::chc] get {$f1: Unknown, $f2: Unknown}
[slotted_egraphs::egraph::add] classes insert id1
[slotted_egraphs::egraph::add] add to id1 PredSyntax([id0: ($f0 -> $0), id0: ($f0 -> $1)])
[slotted_egraphs::egraph::add] remove from id1 PredSyntax([id0: ($f0 -> $0), id0: ($f0 -> $1)])
[slotted_egraphs::egraph::add] add to id1 PredSyntax([id0: ($f0 -> $0), id0: ($f0 -> $1)])
[entry::chc] calling make on PredSyntax([id0: ($f0 -> $0), id0: ($f0 -> $1)])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f1, $f2}
[entry::chc] childId : id0, mapToS : $f0
[entry::chc] adding $f1 to varTypes
[entry::chc] childId : id0, mapToS : $f0
[entry::chc] adding $f2 to varTypes
[entry::chc] aggregateVarType for PredSyntax([id0: ($f0 -> $f1), id0: ($f0 -> $f2)])
[entry::chc] get {$f1: Unknown, $f2: Unknown}
[entry::chc] calling merge to id1
[entry::chc] eclassSlots {$f2, $f1}
[entry::chc] result varTypes {$f1: Unknown, $f2: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id1 <-> (pred <(var $0) (var $1)>)
[entry::chc] calling make on True
[entry::chc] aggregateVarType
[entry::chc] slots: {}
[entry::chc] aggregateVarType for True
[entry::chc] get {}
[slotted_egraphs::egraph::add] classes insert id2
[slotted_egraphs::egraph::add] add to id2 True
[slotted_egraphs::egraph::add] remove from id2 True
[slotted_egraphs::egraph::add] add to id2 True
[entry::chc] calling make on True
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {}
[entry::chc] aggregateVarType for True
[entry::chc] get {}
[entry::chc] calling merge to id2
[entry::chc] eclassSlots {}
[entry::chc] result varTypes {}
[slotted_egraphs::egraph::add] add_syn_expr: id2 <-> (true)
[slotted_egraphs::egraph::add] add_syn_expr: id0 <-> (var $0)
[slotted_egraphs::egraph::add] add_syn_expr: id0 <-> (var $1)
[slotted_egraphs::egraph::add] add_syn_expr: id1 <-> (pred <(var $0) (var $1)>)
[slotted_egraphs::egraph::add] add_syn_expr: id2 <-> (true)
[slotted_egraphs::egraph::add] add_syn_expr: id0 <-> (var $0)
[entry::chc] calling make on PredSyntax([id0: ($f0 -> $f3)])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f3}
[entry::chc] childId : id0, mapToS : $f0
[entry::chc] adding $f3 to varTypes
[entry::chc] aggregateVarType for PredSyntax([id0: ($f0 -> $f3)])
[entry::chc] get {$f3: Unknown}
[slotted_egraphs::egraph::add] classes insert id3
[slotted_egraphs::egraph::add] add to id3 PredSyntax([id0: ($f0 -> $0)])
[slotted_egraphs::egraph::add] remove from id3 PredSyntax([id0: ($f0 -> $0)])
[slotted_egraphs::egraph::add] add to id3 PredSyntax([id0: ($f0 -> $0)])
[entry::chc] calling make on PredSyntax([id0: ($f0 -> $0)])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f3}
[entry::chc] childId : id0, mapToS : $f0
[entry::chc] adding $f3 to varTypes
[entry::chc] aggregateVarType for PredSyntax([id0: ($f0 -> $f3)])
[entry::chc] get {$f3: Unknown}
[entry::chc] calling merge to id3
[entry::chc] eclassSlots {$f3}
[entry::chc] result varTypes {$f3: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id3 <-> (pred <(var $0)>)
[slotted_egraphs::egraph::add] add_syn_expr: id2 <-> (true)
[entry::chc] calling make on New(id3: ($f3 -> $f4), id2: (), [])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f4}
[entry::chc] childId : id3, mapToS : $f3
[entry::chc] adding $f4 to varTypes
[entry::chc] aggregateVarType for New(id3: ($f3 -> $f4), id2: (), [])
[entry::chc] get {$f4: Unknown}
[slotted_egraphs::egraph::add] classes insert id4
[slotted_egraphs::egraph::add] add to id4 New(id3: ($f3 -> $0), id2: (), [])
[slotted_egraphs::egraph::add] remove from id4 New(id3: ($f3 -> $0), id2: (), [])
[slotted_egraphs::egraph::add] add to id4 New(id3: ($f3 -> $0), id2: (), [])
[entry::chc] calling make on New(id3: ($f3 -> $0), id2: (), [])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f4}
[entry::chc] childId : id3, mapToS : $f3
[entry::chc] adding $f4 to varTypes
[entry::chc] aggregateVarType for New(id3: ($f3 -> $f4), id2: (), [])
[entry::chc] get {$f4: Unknown}
[entry::chc] calling merge to id4
[entry::chc] eclassSlots {$f4}
[entry::chc] result varTypes {$f4: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id4 <-> (new (pred <(var $0)>) (true) <>)
[entry::chc] calling make on Compose([AppliedId(id4: ($f4 -> $f5))])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f5}
[entry::chc] childId : id4, mapToS : $f4
[entry::chc] adding $f5 to varTypes
[entry::chc] aggregateVarType for Compose([AppliedId(id4: ($f4 -> $f5))])
[entry::chc] get {$f5: Unknown}
[slotted_egraphs::egraph::add] classes insert id5
[slotted_egraphs::egraph::add] add to id5 Compose([AppliedId(id4: ($f4 -> $0))])
[slotted_egraphs::egraph::add] remove from id5 Compose([AppliedId(id4: ($f4 -> $0))])
[slotted_egraphs::egraph::add] add to id5 Compose([AppliedId(id4: ($f4 -> $0))])
[entry::chc] calling make on Compose([AppliedId(id4: ($f4 -> $0))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f5}
[entry::chc] childId : id4, mapToS : $f4
[entry::chc] adding $f5 to varTypes
[entry::chc] aggregateVarType for Compose([AppliedId(id4: ($f4 -> $f5))])
[entry::chc] get {$f5: Unknown}
[entry::chc] calling merge to id5
[entry::chc] eclassSlots {$f5}
[entry::chc] result varTypes {$f5: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id5 <-> (compose <(new (pred <(var $0)>) (true) <>)>)
[slotted_egraphs::egraph::add] add_syn_expr: id0 <-> (var $1)
[slotted_egraphs::egraph::add] add_syn_expr: id3 <-> (pred <(var $1)>)
[slotted_egraphs::egraph::add] add_syn_expr: id2 <-> (true)
[slotted_egraphs::egraph::add] add_syn_expr: id4 <-> (new (pred <(var $1)>) (true) <>)
[slotted_egraphs::egraph::add] add_syn_expr: id5 <-> (compose <(new (pred <(var $1)>) (true) <>)>)
[entry::chc] calling make on New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f6, $f7}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f6 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f6 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f7 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f7 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
[entry::chc] get {$f6: Unknown, $f7: Unknown}
[slotted_egraphs::egraph::add] classes insert id6
[slotted_egraphs::egraph::add] add to id6 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id5: ($f5 -> $1))])
[slotted_egraphs::egraph::add] remove from id6 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id5: ($f5 -> $1))])
[slotted_egraphs::egraph::add] add to id6 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id5: ($f5 -> $1))])
[entry::chc] calling make on New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id5: ($f5 -> $1))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f6, $f7}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f6 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f6 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f7 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f7 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
[entry::chc] get {$f6: Unknown, $f7: Unknown}
[entry::chc] calling merge to id6
[entry::chc] eclassSlots {$f7, $f6}
[entry::chc] result varTypes {$f7: Unknown, $f6: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id6 <-> (new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0)>) (true) <>)>) (compose <(new (pred <(var $1)>) (true) <>)>)>)
[entry::chc] calling make on Compose([AppliedId(id6: ($f6 -> $f8, $f7 -> $f9))])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f8, $f9}
[entry::chc] childId : id6, mapToS : $f6
[entry::chc] adding $f8 to varTypes
[entry::chc] childId : id6, mapToS : $f7
[entry::chc] adding $f9 to varTypes
[entry::chc] aggregateVarType for Compose([AppliedId(id6: ($f6 -> $f8, $f7 -> $f9))])
[entry::chc] get {$f8: Unknown, $f9: Unknown}
[slotted_egraphs::egraph::add] classes insert id7
[slotted_egraphs::egraph::add] add to id7 Compose([AppliedId(id6: ($f6 -> $0, $f7 -> $1))])
[slotted_egraphs::egraph::add] remove from id7 Compose([AppliedId(id6: ($f6 -> $0, $f7 -> $1))])
[slotted_egraphs::egraph::add] add to id7 Compose([AppliedId(id6: ($f6 -> $0, $f7 -> $1))])
[entry::chc] calling make on Compose([AppliedId(id6: ($f6 -> $0, $f7 -> $1))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f8, $f9}
[entry::chc] childId : id6, mapToS : $f6
[entry::chc] adding $f8 to varTypes
[entry::chc] childId : id6, mapToS : $f7
[entry::chc] adding $f9 to varTypes
[entry::chc] aggregateVarType for Compose([AppliedId(id6: ($f6 -> $f8, $f7 -> $f9))])
[entry::chc] get {$f9: Unknown, $f8: Unknown}
[entry::chc] calling merge to id7
[entry::chc] eclassSlots {$f8, $f9}
[entry::chc] result varTypes {$f8: Unknown, $f9: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id7 <-> (compose <(new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0)>) (true) <>)>) (compose <(new (pred <(var $1)>) (true) <>)>)>)>)
[slotted_egraphs::egraph::add] add_syn_expr: id0 <-> (var $0)
[slotted_egraphs::egraph::add] add_syn_expr: id3 <-> (pred <(var $0)>)
[slotted_egraphs::egraph::add] add_syn_expr: id2 <-> (true)
[slotted_egraphs::egraph::add] add_syn_expr: id4 <-> (new (pred <(var $0)>) (true) <>)
[slotted_egraphs::egraph::add] add_syn_expr: id5 <-> (compose <(new (pred <(var $0)>) (true) <>)>)
[entry::chc] calling make on New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f10, $f11}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f10 to varTypes
[entry::chc] childId : id7, mapToS : $f8
[entry::chc] adding $f10 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f10 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f11 to varTypes
[entry::chc] childId : id7, mapToS : $f9
[entry::chc] adding $f11 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
[entry::chc] get {$f10: Unknown, $f11: Unknown}
[slotted_egraphs::egraph::add] classes insert id8
[slotted_egraphs::egraph::add] add to id8 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id7: ($f8 -> $0, $f9 -> $1)), AppliedId(id5: ($f5 -> $0))])
[slotted_egraphs::egraph::add] remove from id8 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id7: ($f8 -> $0, $f9 -> $1)), AppliedId(id5: ($f5 -> $0))])
[slotted_egraphs::egraph::add] add to id8 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id7: ($f8 -> $0, $f9 -> $1)), AppliedId(id5: ($f5 -> $0))])
[entry::chc] calling make on New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id7: ($f8 -> $0, $f9 -> $1)), AppliedId(id5: ($f5 -> $0))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f10, $f11}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f10 to varTypes
[entry::chc] childId : id7, mapToS : $f8
[entry::chc] adding $f10 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f10 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f11 to varTypes
[entry::chc] childId : id7, mapToS : $f9
[entry::chc] adding $f11 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
[entry::chc] get {$f11: Unknown, $f10: Unknown}
[entry::chc] calling merge to id8
[entry::chc] eclassSlots {$f11, $f10}
[entry::chc] result varTypes {$f11: Unknown, $f10: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id8 <-> (new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0)>) (true) <>)>) (compose <(new (pred <(var $1)>) (true) <>)>)>)>) (compose <(new (pred <(var $0)>) (true) <>)>)>)
[slotted_egraphs::egraph::add] add_syn_expr: id0 <-> (var $0)
[slotted_egraphs::egraph::add] add_syn_expr: id0 <-> (var $1)
[slotted_egraphs::egraph::add] add_syn_expr: id1 <-> (pred <(var $0) (var $1)>)
[slotted_egraphs::egraph::add] add_syn_expr: id2 <-> (true)
[entry::chc] calling make on New(id1: ($f1 -> $f12, $f2 -> $f13), id2: (), [])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f12, $f13}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f12 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f13 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f12, $f2 -> $f13), id2: (), [])
[entry::chc] get {$f12: Unknown, $f13: Unknown}
[slotted_egraphs::egraph::add] classes insert id9
[slotted_egraphs::egraph::add] add to id9 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [])
[slotted_egraphs::egraph::add] remove from id9 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [])
[slotted_egraphs::egraph::add] add to id9 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [])
[entry::chc] calling make on New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f12, $f13}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f12 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f13 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f12, $f2 -> $f13), id2: (), [])
[entry::chc] get {$f12: Unknown, $f13: Unknown}
[entry::chc] calling merge to id9
[entry::chc] eclassSlots {$f13, $f12}
[entry::chc] result varTypes {$f13: Unknown, $f12: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id9 <-> (new (pred <(var $0) (var $1)>) (true) <>)
[entry::chc] calling make on Compose([AppliedId(id8: ($f10 -> $f14, $f11 -> $f15)), AppliedId(id9: ($f12 -> $f14, $f13 -> $f15))])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f14, $f15}
[entry::chc] childId : id8, mapToS : $f10
[entry::chc] adding $f14 to varTypes
[entry::chc] childId : id9, mapToS : $f12
[entry::chc] adding $f14 to varTypes
[entry::chc] childId : id8, mapToS : $f11
[entry::chc] adding $f15 to varTypes
[entry::chc] childId : id9, mapToS : $f13
[entry::chc] adding $f15 to varTypes
[entry::chc] aggregateVarType for Compose([AppliedId(id8: ($f10 -> $f14, $f11 -> $f15)), AppliedId(id9: ($f12 -> $f14, $f13 -> $f15))])
[entry::chc] get {$f14: Unknown, $f15: Unknown}
[slotted_egraphs::egraph::add] classes insert id10
[slotted_egraphs::egraph::add] add to id10 Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))])
[slotted_egraphs::egraph::add] remove from id10 Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))])
[slotted_egraphs::egraph::add] add to id10 Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))])
[entry::chc] calling make on Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f14, $f15}
[entry::chc] childId : id8, mapToS : $f10
[entry::chc] adding $f14 to varTypes
[entry::chc] childId : id9, mapToS : $f12
[entry::chc] adding $f14 to varTypes
[entry::chc] childId : id8, mapToS : $f11
[entry::chc] adding $f15 to varTypes
[entry::chc] childId : id9, mapToS : $f13
[entry::chc] adding $f15 to varTypes
[entry::chc] aggregateVarType for Compose([AppliedId(id8: ($f10 -> $f14, $f11 -> $f15)), AppliedId(id9: ($f12 -> $f14, $f13 -> $f15))])
[entry::chc] get {$f14: Unknown, $f15: Unknown}
[entry::chc] calling merge to id10
[entry::chc] eclassSlots {$f14, $f15}
[entry::chc] result varTypes {$f14: Unknown, $f15: Unknown}
[slotted_egraphs::egraph::add] add_syn_expr: id10 <-> (compose <(new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0) (var $1)>) (true) <(compose <(new (pred <(var $0)>) (true) <>)>) (compose <(new (pred <(var $1)>) (true) <>)>)>)>) (compose <(new (pred <(var $0)>) (true) <>)>)>) (new (pred <(var $0) (var $1)>) (true) <>)>)
[slotted_egraphs::parse] from (compose <(new ?syntax1 (and <*0>) <(compose <*1>) *2> ) *3>)
[slotted_egraphs::parse] to tokens [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), PVar("syntax1"), LParen, Ident("and"), LVecBracket, Star(0), RVecBracket, RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, Star(1), RVecBracket, RParen, Star(2), RVecBracket, RParen, Star(3), RVecBracket, RParen]
[slotted_egraphs::parse] from (new ?syntax ?cond <*1>)
[slotted_egraphs::parse] to tokens [LParen, Ident("new"), PVar("syntax"), PVar("cond"), LVecBracket, Star(1), RVecBracket, RParen]
[slotted_egraphs::parse] from (compose <*1>)
[slotted_egraphs::parse] to tokens [LParen, Ident("compose"), LVecBracket, Star(1), RVecBracket, RParen]
[slotted_egraphs::parse] from (new ?syntax ?cond <*1>)
[slotted_egraphs::parse] to tokens [LParen, Ident("new"), PVar("syntax"), PVar("cond"), LVecBracket, Star(1), RVecBracket, RParen]
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = (compose <(new ?syntax1 (and <*0>) <(compose <*1>) *2>) *3>)
[slotted_egraphs::rewrite::ematch] insert syntax1 -> id1: ($f1 -> $f14, $f2 -> $f15) to subst
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = (new ?syntax ?cond <*1>)
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f6, $f2 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id5: ($f5 -> $f6) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f10, $f2 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id7: ($f8 -> $f10, $f9 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f10) to subst
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = (compose <*1>)
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id4: ($f4 -> $f5) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id6: ($f6 -> $f8, $f7 -> $f9) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id8: ($f10 -> $f14, $f11 -> $f15) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id9: ($f12 -> $f14, $f13 -> $f15) to subst
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = (new ?syntax ?cond <*1>)
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f6, $f2 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id5: ($f5 -> $f6) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f10, $f2 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id7: ($f8 -> $f10, $f9 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f10) to subst
[entry::chc::rewrite] unfold rule, found []
[slotted_egraphs::parse] from (new ?syntax ?cond <*2>)
[slotted_egraphs::parse] to tokens [LParen, Ident("new"), PVar("syntax"), PVar("cond"), LVecBracket, Star(2), RVecBracket, RParen]
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id6: ($f6 -> $f17, $f7 -> $f16) with id6: ($f6 -> $f17, $f7 -> $f16)
[entry::chc] calling make on New(id1: ($f1 -> $f30, $f2 -> $f29), id2: (), [AppliedId(id5: ($f5 -> $f29)), AppliedId(id5: ($f5 -> $f30))])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f29, $f30}
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f29 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f29 to varTypes
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f30 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f30 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f30, $f2 -> $f29), id2: (), [AppliedId(id5: ($f5 -> $f29)), AppliedId(id5: ($f5 -> $f30))])
[entry::chc] get {$f29: Unknown, $f30: Unknown}
[slotted_egraphs::egraph::add] classes insert id11
[slotted_egraphs::egraph::add] add to id11 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))])
[slotted_egraphs::egraph::add] remove from id11 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))])
[slotted_egraphs::egraph::add] add to id11 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))])
[entry::chc] calling make on New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f29, $f30}
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f29 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f29 to varTypes
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f30 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f30 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f30, $f2 -> $f29), id2: (), [AppliedId(id5: ($f5 -> $f29)), AppliedId(id5: ($f5 -> $f30))])
[entry::chc] get {$f30: Unknown, $f29: Unknown}
[entry::chc] calling merge to id11
[entry::chc] eclassSlots {$f29, $f30}
[entry::chc] result varTypes {$f30: Unknown, $f29: Unknown}
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id6: ($f6 -> $f17, $f7 -> $f16) with id11: ($f29 -> $f16, $f30 -> $f17)
[slotted_egraphs::egraph::union] Call move_to id11: ($f29 -> $f16, $f30 -> $f17), id6: ($f6 -> $f17, $f7 -> $f16)
[entry::chc] calling merge to id6
[entry::chc] eclassSlots {$f7, $f6}
[entry::chc] result varTypes {$f7: Unknown, $f6: Unknown}
[slotted_egraphs::egraph::add] remove from id11 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))])
[slotted_egraphs::egraph::add] add to id6 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))])
[slotted_egraphs::egraph::union] adding New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))]) to self.pending
[slotted_egraphs::egraph::add] remove from id6 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))])
[slotted_egraphs::egraph::add] add to id6 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))])
[entry::chc] calling make on New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $1)), AppliedId(id5: ($f5 -> $0))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f6, $f7}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f6 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f6 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f7 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f7 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f7)), AppliedId(id5: ($f5 -> $f6))])
[entry::chc] get {$f6: Unknown, $f7: Unknown}
[entry::chc] calling merge to id6
[entry::chc] eclassSlots {$f7, $f6}
[entry::chc] result varTypes {$f7: Unknown, $f6: Unknown}
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id8: ($f10 -> $f18, $f11 -> $f19) with id8: ($f10 -> $f18, $f11 -> $f19)
[entry::chc] calling make on New(id1: ($f1 -> $f31, $f2 -> $f32), id2: (), [AppliedId(id5: ($f5 -> $f31)), AppliedId(id7: ($f8 -> $f31, $f9 -> $f32))])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f31, $f32}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f31 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f31 to varTypes
[entry::chc] childId : id7, mapToS : $f8
[entry::chc] adding $f31 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f32 to varTypes
[entry::chc] childId : id7, mapToS : $f9
[entry::chc] adding $f32 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f31, $f2 -> $f32), id2: (), [AppliedId(id5: ($f5 -> $f31)), AppliedId(id7: ($f8 -> $f31, $f9 -> $f32))])
[entry::chc] get {$f31: Unknown, $f32: Unknown}
[slotted_egraphs::egraph::add] classes insert id12
[slotted_egraphs::egraph::add] add to id12 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))])
[slotted_egraphs::egraph::add] remove from id12 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))])
[slotted_egraphs::egraph::add] add to id12 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))])
[entry::chc] calling make on New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f31, $f32}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f31 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f31 to varTypes
[entry::chc] childId : id7, mapToS : $f8
[entry::chc] adding $f31 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f32 to varTypes
[entry::chc] childId : id7, mapToS : $f9
[entry::chc] adding $f32 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f31, $f2 -> $f32), id2: (), [AppliedId(id5: ($f5 -> $f31)), AppliedId(id7: ($f8 -> $f31, $f9 -> $f32))])
[entry::chc] get {$f31: Unknown, $f32: Unknown}
[entry::chc] calling merge to id12
[entry::chc] eclassSlots {$f32, $f31}
[entry::chc] result varTypes {$f32: Unknown, $f31: Unknown}
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id8: ($f10 -> $f18, $f11 -> $f19) with id12: ($f31 -> $f18, $f32 -> $f19)
[slotted_egraphs::egraph::union] Call move_to id12: ($f31 -> $f18, $f32 -> $f19), id8: ($f10 -> $f18, $f11 -> $f19)
[entry::chc] calling merge to id8
[entry::chc] eclassSlots {$f11, $f10}
[entry::chc] result varTypes {$f10: Unknown, $f11: Unknown}
[slotted_egraphs::egraph::add] remove from id12 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))])
[slotted_egraphs::egraph::add] add to id8 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))])
[slotted_egraphs::egraph::union] adding New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))]) to self.pending
[slotted_egraphs::egraph::add] remove from id8 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))])
[slotted_egraphs::egraph::add] add to id8 New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))])
[entry::chc] calling make on New(id1: ($f1 -> $0, $f2 -> $1), id2: (), [AppliedId(id5: ($f5 -> $0)), AppliedId(id7: ($f8 -> $0, $f9 -> $1))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f10, $f11}
[entry::chc] childId : id1, mapToS : $f1
[entry::chc] adding $f10 to varTypes
[entry::chc] childId : id5, mapToS : $f5
[entry::chc] adding $f10 to varTypes
[entry::chc] childId : id7, mapToS : $f8
[entry::chc] adding $f10 to varTypes
[entry::chc] childId : id1, mapToS : $f2
[entry::chc] adding $f11 to varTypes
[entry::chc] childId : id7, mapToS : $f9
[entry::chc] adding $f11 to varTypes
[entry::chc] aggregateVarType for New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id5: ($f5 -> $f10)), AppliedId(id7: ($f8 -> $f10, $f9 -> $f11))])
[entry::chc] get {$f10: Unknown, $f11: Unknown}
[entry::chc] calling merge to id8
[entry::chc] eclassSlots {$f11, $f10}
[entry::chc] result varTypes {$f11: Unknown, $f10: Unknown}
[slotted_egraphs::parse] from (compose <*2>)
[slotted_egraphs::parse] to tokens [LParen, Ident("compose"), LVecBracket, Star(2), RVecBracket, RParen]
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id5: ($f5 -> $f20) with id5: ($f5 -> $f20)
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id7: ($f8 -> $f21, $f9 -> $f22) with id7: ($f8 -> $f21, $f9 -> $f22)
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id10: ($f14 -> $f23, $f15 -> $f24) with id10: ($f14 -> $f23, $f15 -> $f24)
[entry::chc] calling make on Compose([AppliedId(id9: ($f12 -> $f33, $f13 -> $f34)), AppliedId(id8: ($f10 -> $f33, $f11 -> $f34))])
[entry::chc] aggregateVarType
[entry::chc] slots: {$f33, $f34}
[entry::chc] childId : id9, mapToS : $f12
[entry::chc] adding $f33 to varTypes
[entry::chc] childId : id8, mapToS : $f10
[entry::chc] adding $f33 to varTypes
[entry::chc] childId : id9, mapToS : $f13
[entry::chc] adding $f34 to varTypes
[entry::chc] childId : id8, mapToS : $f11
[entry::chc] adding $f34 to varTypes
[entry::chc] aggregateVarType for Compose([AppliedId(id9: ($f12 -> $f33, $f13 -> $f34)), AppliedId(id8: ($f10 -> $f33, $f11 -> $f34))])
[entry::chc] get {$f34: Unknown, $f33: Unknown}
[slotted_egraphs::egraph::add] classes insert id13
[slotted_egraphs::egraph::add] add to id13 Compose([AppliedId(id9: ($f12 -> $0, $f13 -> $1)), AppliedId(id8: ($f10 -> $0, $f11 -> $1))])
[slotted_egraphs::egraph::add] remove from id13 Compose([AppliedId(id9: ($f12 -> $0, $f13 -> $1)), AppliedId(id8: ($f10 -> $0, $f11 -> $1))])
[slotted_egraphs::egraph::add] add to id13 Compose([AppliedId(id9: ($f12 -> $0, $f13 -> $1)), AppliedId(id8: ($f10 -> $0, $f11 -> $1))])
[entry::chc] calling make on Compose([AppliedId(id9: ($f12 -> $0, $f13 -> $1)), AppliedId(id8: ($f10 -> $0, $f11 -> $1))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f33, $f34}
[entry::chc] childId : id9, mapToS : $f12
[entry::chc] adding $f33 to varTypes
[entry::chc] childId : id8, mapToS : $f10
[entry::chc] adding $f33 to varTypes
[entry::chc] childId : id9, mapToS : $f13
[entry::chc] adding $f34 to varTypes
[entry::chc] childId : id8, mapToS : $f11
[entry::chc] adding $f34 to varTypes
[entry::chc] aggregateVarType for Compose([AppliedId(id9: ($f12 -> $f33, $f13 -> $f34)), AppliedId(id8: ($f10 -> $f33, $f11 -> $f34))])
[entry::chc] get {$f34: Unknown, $f33: Unknown}
[entry::chc] calling merge to id13
[entry::chc] eclassSlots {$f34, $f33}
[entry::chc] result varTypes {$f34: Unknown, $f33: Unknown}
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id10: ($f14 -> $f23, $f15 -> $f24) with id13: ($f33 -> $f23, $f34 -> $f24)
[slotted_egraphs::egraph::union] Call move_to id10: ($f14 -> $f23, $f15 -> $f24), id13: ($f33 -> $f23, $f34 -> $f24)
[entry::chc] calling merge to id13
[entry::chc] eclassSlots {$f34, $f33}
[entry::chc] result varTypes {$f33: Unknown, $f34: Unknown}
[slotted_egraphs::egraph::add] remove from id10 Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))])
[slotted_egraphs::egraph::add] add to id13 Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))])
[slotted_egraphs::egraph::union] adding Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))]) to self.pending
[slotted_egraphs::egraph::add] remove from id13 Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))])
[slotted_egraphs::egraph::add] add to id13 Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))])
[entry::chc] calling make on Compose([AppliedId(id8: ($f10 -> $0, $f11 -> $1)), AppliedId(id9: ($f12 -> $0, $f13 -> $1))])
[entry::chc] aggregateVarType
[entry::chc] exists in egraph
[entry::chc] slots: {$f33, $f34}
[entry::chc] childId : id8, mapToS : $f10
[entry::chc] adding $f33 to varTypes
[entry::chc] childId : id9, mapToS : $f12
[entry::chc] adding $f33 to varTypes
[entry::chc] childId : id8, mapToS : $f11
[entry::chc] adding $f34 to varTypes
[entry::chc] childId : id9, mapToS : $f13
[entry::chc] adding $f34 to varTypes
[entry::chc] aggregateVarType for Compose([AppliedId(id8: ($f10 -> $f33, $f11 -> $f34)), AppliedId(id9: ($f12 -> $f33, $f13 -> $f34))])
[entry::chc] get {$f33: Unknown, $f34: Unknown}
[entry::chc] calling merge to id13
[entry::chc] eclassSlots {$f34, $f33}
[entry::chc] result varTypes {$f34: Unknown, $f33: Unknown}
[entry::chc::rewrite] define found [{"cond": id2: (), "star_1_1": id5: ($f5 -> $f25), "star_1_0": id5: ($f5 -> $f26), "syntax": id1: ($f1 -> $f26, $f2 -> $f25)}, {"cond": id2: (), "star_1_1": id5: ($f5 -> $f27), "star_1_0": id7: ($f8 -> $f27, $f9 -> $f28), "syntax": id1: ($f1 -> $f27, $f2 -> $f28)}]
[entry::chc::rewrite] root eclass id6 
    CHCData { predNames: {}, varTypes: {$f7: Unknown, $f6: Unknown} }
    ($f6, $f7):>> New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
     - New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
     - New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f7)), AppliedId(id5: ($f5 -> $f6))])
    
[entry::chc::rewrite] childAppIds [
        id5: ($f5 -> $f6),
        id5: ($f5 -> $f7),
    ]
[entry::chc::rewrite] appId.slots {$f6}
[entry::chc::rewrite] appId.slots {$f7}
[entry::chc::rewrite] mergeVarTypes = {
        $f6: Unknown,
        $f7: Unknown,
    }
[entry::chc::rewrite] varToChildIndx = {
        $f6: [
            0,
        ],
        $f7: [
            1,
        ],
    }
[entry::chc::rewrite] var = $f6
[entry::chc::rewrite] var = $f7
[entry::chc::rewrite] root eclass id8 
    CHCData { predNames: {}, varTypes: {$f11: Unknown, $f10: Unknown} }
    ($f10, $f11):>> New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
     - New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
     - New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id5: ($f5 -> $f10)), AppliedId(id7: ($f8 -> $f10, $f9 -> $f11))])
    
[entry::chc::rewrite] childAppIds [
        id7: ($f8 -> $f10, $f9 -> $f11),
        id5: ($f5 -> $f10),
    ]
[entry::chc::rewrite] appId.slots {$f10, $f11}
[entry::chc::rewrite] appId.slots {$f10}
[entry::chc::rewrite] mergeVarTypes = {
        $f10: Unknown,
        $f11: Unknown,
    }
[entry::chc::rewrite] varToChildIndx = {
        $f11: [
            0,
        ],
        $f10: [
            0,
            1,
        ],
    }
[entry::chc::rewrite] var = $f11
[entry::chc::rewrite] var = $f10
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = (compose <(new ?syntax1 (and <*0>) <(compose <*1>) *2>) *3>)
[slotted_egraphs::rewrite::ematch] insert syntax1 -> id1: ($f1 -> $f33, $f2 -> $f34) to subst
[slotted_egraphs::rewrite::ematch] insert syntax1 -> id1: ($f1 -> $f33, $f2 -> $f34) to subst
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = (new ?syntax ?cond <*1>)
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f6, $f2 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id5: ($f5 -> $f6) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f6, $f2 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id5: ($f5 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f6) to subst
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f10, $f2 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id7: ($f8 -> $f10, $f9 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f10) to subst
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f10, $f2 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id5: ($f5 -> $f10) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id7: ($f8 -> $f10, $f9 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = (compose <*1>)
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id4: ($f4 -> $f5) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id6: ($f6 -> $f8, $f7 -> $f9) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id9: ($f12 -> $f33, $f13 -> $f34) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id8: ($f10 -> $f33, $f11 -> $f34) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id8: ($f10 -> $f33, $f11 -> $f34) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id9: ($f12 -> $f33, $f13 -> $f34) to subst
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = (new ?syntax ?cond <*1>)
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f6, $f2 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id5: ($f5 -> $f6) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f6, $f2 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id5: ($f5 -> $f7) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f6) to subst
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f10, $f2 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id7: ($f8 -> $f10, $f9 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id5: ($f5 -> $f10) to subst
[slotted_egraphs::rewrite::ematch] insert syntax -> id1: ($f1 -> $f10, $f2 -> $f11) to subst
[slotted_egraphs::rewrite::ematch] insert cond -> id2: () to subst
[slotted_egraphs::rewrite::ematch] insert star_1_0 -> id5: ($f5 -> $f10) to subst
[slotted_egraphs::rewrite::ematch] insert star_1_1 -> id7: ($f8 -> $f10, $f9 -> $f11) to subst
[entry::chc::rewrite] unfold rule, found []
[slotted_egraphs::parse] from (new ?syntax ?cond <*2>)
[slotted_egraphs::parse] to tokens [LParen, Ident("new"), PVar("syntax"), PVar("cond"), LVecBracket, Star(2), RVecBracket, RParen]
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id6: ($f6 -> $f36, $f7 -> $f35) with id6: ($f6 -> $f36, $f7 -> $f35)
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id6: ($f6 -> $f36, $f7 -> $f35) with id6: ($f6 -> $f36, $f7 -> $f35)
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id6: ($f6 -> $f37, $f7 -> $f38) with id6: ($f6 -> $f37, $f7 -> $f38)
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id6: ($f6 -> $f37, $f7 -> $f38) with id6: ($f6 -> $f37, $f7 -> $f38)
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id8: ($f10 -> $f39, $f11 -> $f40) with id8: ($f10 -> $f39, $f11 -> $f40)
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id8: ($f10 -> $f39, $f11 -> $f40) with id8: ($f10 -> $f39, $f11 -> $f40)
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id8: ($f10 -> $f41, $f11 -> $f42) with id8: ($f10 -> $f41, $f11 -> $f42)
[slotted_egraphs::egraph::union] Union because Some("newChildrenPermute"), id8: ($f10 -> $f41, $f11 -> $f42) with id8: ($f10 -> $f41, $f11 -> $f42)
[slotted_egraphs::parse] from (compose <*2>)
[slotted_egraphs::parse] to tokens [LParen, Ident("compose"), LVecBracket, Star(2), RVecBracket, RParen]
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id5: ($f5 -> $f43) with id5: ($f5 -> $f43)
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id7: ($f8 -> $f44, $f9 -> $f45) with id7: ($f8 -> $f44, $f9 -> $f45)
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id13: ($f33 -> $f46, $f34 -> $f47) with id13: ($f33 -> $f46, $f34 -> $f47)
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id13: ($f33 -> $f46, $f34 -> $f47) with id13: ($f33 -> $f46, $f34 -> $f47)
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id13: ($f33 -> $f48, $f34 -> $f49) with id13: ($f33 -> $f48, $f34 -> $f49)
[slotted_egraphs::egraph::union] Union because Some("composeChildrenPermute"), id13: ($f33 -> $f48, $f34 -> $f49) with id13: ($f33 -> $f48, $f34 -> $f49)
[entry::chc::rewrite] define found [{"cond": id2: (), "star_1_1": id5: ($f5 -> $f50), "star_1_0": id5: ($f5 -> $f51), "syntax": id1: ($f1 -> $f51, $f2 -> $f50)}, {"cond": id2: (), "star_1_1": id5: ($f5 -> $f52), "star_1_0": id5: ($f5 -> $f53), "syntax": id1: ($f1 -> $f52, $f2 -> $f53)}, {"cond": id2: (), "star_1_1": id5: ($f5 -> $f54), "star_1_0": id7: ($f8 -> $f54, $f9 -> $f55), "syntax": id1: ($f1 -> $f54, $f2 -> $f55)}, {"cond": id2: (), "star_1_1": id7: ($f8 -> $f56, $f9 -> $f57), "star_1_0": id5: ($f5 -> $f56), "syntax": id1: ($f1 -> $f56, $f2 -> $f57)}]
[entry::chc::rewrite] root eclass id6 
    CHCData { predNames: {}, varTypes: {$f7: Unknown, $f6: Unknown} }
    ($f6, $f7):>> New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
     - New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
     - New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f7)), AppliedId(id5: ($f5 -> $f6))])
    
[entry::chc::rewrite] childAppIds [
        id5: ($f5 -> $f6),
        id5: ($f5 -> $f7),
    ]
[entry::chc::rewrite] appId.slots {$f6}
[entry::chc::rewrite] appId.slots {$f7}
[entry::chc::rewrite] mergeVarTypes = {
        $f6: Unknown,
        $f7: Unknown,
    }
[entry::chc::rewrite] varToChildIndx = {
        $f6: [
            0,
        ],
        $f7: [
            1,
        ],
    }
[entry::chc::rewrite] var = $f6
[entry::chc::rewrite] var = $f7
[entry::chc::rewrite] root eclass id6 
    CHCData { predNames: {}, varTypes: {$f7: Unknown, $f6: Unknown} }
    ($f6, $f7):>> New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
     - New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
     - New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f7)), AppliedId(id5: ($f5 -> $f6))])
    
[entry::chc::rewrite] childAppIds [
        id5: ($f5 -> $f7),
        id5: ($f5 -> $f6),
    ]
[entry::chc::rewrite] appId.slots {$f7}
[entry::chc::rewrite] appId.slots {$f6}
[entry::chc::rewrite] mergeVarTypes = {
        $f6: Unknown,
        $f7: Unknown,
    }
[entry::chc::rewrite] varToChildIndx = {
        $f6: [
            1,
        ],
        $f7: [
            0,
        ],
    }
[entry::chc::rewrite] var = $f6
[entry::chc::rewrite] var = $f7
[entry::chc::rewrite] root eclass id8 
    CHCData { predNames: {}, varTypes: {$f11: Unknown, $f10: Unknown} }
    ($f10, $f11):>> New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
     - New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
     - New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id5: ($f5 -> $f10)), AppliedId(id7: ($f8 -> $f10, $f9 -> $f11))])
    
[entry::chc::rewrite] childAppIds [
        id7: ($f8 -> $f10, $f9 -> $f11),
        id5: ($f5 -> $f10),
    ]
[entry::chc::rewrite] appId.slots {$f10, $f11}
[entry::chc::rewrite] appId.slots {$f10}
[entry::chc::rewrite] mergeVarTypes = {
        $f10: Unknown,
        $f11: Unknown,
    }
[entry::chc::rewrite] varToChildIndx = {
        $f10: [
            0,
            1,
        ],
        $f11: [
            0,
        ],
    }
[entry::chc::rewrite] var = $f10
[entry::chc::rewrite] var = $f11
[entry::chc::rewrite] root eclass id8 
    CHCData { predNames: {}, varTypes: {$f11: Unknown, $f10: Unknown} }
    ($f10, $f11):>> New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
     - New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
     - New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id5: ($f5 -> $f10)), AppliedId(id7: ($f8 -> $f10, $f9 -> $f11))])
    
[entry::chc::rewrite] childAppIds [
        id5: ($f5 -> $f10),
        id7: ($f8 -> $f10, $f9 -> $f11),
    ]
[entry::chc::rewrite] appId.slots {$f10}
[entry::chc::rewrite] appId.slots {$f10, $f11}
[entry::chc::rewrite] mergeVarTypes = {
        $f11: Unknown,
        $f10: Unknown,
    }
[entry::chc::rewrite] varToChildIndx = {
        $f11: [
            1,
        ],
        $f10: [
            0,
            1,
        ],
    }
[entry::chc::rewrite] var = $f11
[entry::chc::rewrite] var = $f10
[entry::chc::tst] egraph after

 == Egraph ==
(var $f0)
CHCData { predNames: {}, varTypes: {$f0: Unknown} }
id0($f0):>> Var($f0)
 - Var($f0)

(pred <(var $f1) (var $f2)>)
CHCData { predNames: {}, varTypes: {$f1: Unknown, $f2: Unknown} }
id1($f1, $f2):>> PredSyntax([id0: ($f0 -> $f1), id0: ($f0 -> $f2)])
 - PredSyntax([id0: ($f0 -> $f1), id0: ($f0 -> $f2)])

(true)
CHCData { predNames: {}, varTypes: {} }
id2():>> True
 - True

(pred <(var $f3)>)
CHCData { predNames: {}, varTypes: {$f3: Unknown} }
id3($f3):>> PredSyntax([id0: ($f0 -> $f3)])
 - PredSyntax([id0: ($f0 -> $f3)])

(new (pred <(var $f4)>) (true) <>)
CHCData { predNames: {}, varTypes: {$f4: Unknown} }
id4($f4):>> New(id3: ($f3 -> $f4), id2: (), [])
 - New(id3: ($f3 -> $f4), id2: (), [])

(compose <(new (pred <(var $f5)>) (true) <>)>)
CHCData { predNames: {}, varTypes: {$f5: Unknown} }
id5($f5):>> Compose([AppliedId(id4: ($f4 -> $f5))])
 - Compose([AppliedId(id4: ($f4 -> $f5))])

(new (pred <(var $f6) (var $f7)>) (true) <(compose <(new (pred <(var $f6)>) (true) <>)>) (compose <(new (pred <(var $f7)>) (true) <>)>)>)
CHCData { predNames: {}, varTypes: {$f7: Unknown, $f6: Unknown} }
id6($f6, $f7):>> New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
 - New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f6)), AppliedId(id5: ($f5 -> $f7))])
 - New(id1: ($f1 -> $f6, $f2 -> $f7), id2: (), [AppliedId(id5: ($f5 -> $f7)), AppliedId(id5: ($f5 -> $f6))])

(compose <(new (pred <(var $f8) (var $f9)>) (true) <(compose <(new (pred <(var $f8)>) (true) <>)>) (compose <(new (pred <(var $f9)>) (true) <>)>)>)>)
CHCData { predNames: {}, varTypes: {$f8: Unknown, $f9: Unknown} }
id7($f8, $f9):>> Compose([AppliedId(id6: ($f6 -> $f8, $f7 -> $f9))])
 - Compose([AppliedId(id6: ($f6 -> $f8, $f7 -> $f9))])

(new (pred <(var $f10) (var $f11)>) (true) <(compose <(new (pred <(var $f10) (var $f11)>) (true) <(compose <(new (pred <(var $f10)>) (true) <>)>) (compose <(new (pred <(var $f11)>) (true) <>)>)>)>) (compose <(new (pred <(var $f10)>) (true) <>)>)>)
CHCData { predNames: {}, varTypes: {$f11: Unknown, $f10: Unknown} }
id8($f10, $f11):>> New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
 - New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id7: ($f8 -> $f10, $f9 -> $f11)), AppliedId(id5: ($f5 -> $f10))])
 - New(id1: ($f1 -> $f10, $f2 -> $f11), id2: (), [AppliedId(id5: ($f5 -> $f10)), AppliedId(id7: ($f8 -> $f10, $f9 -> $f11))])

(new (pred <(var $f12) (var $f13)>) (true) <>)
CHCData { predNames: {}, varTypes: {$f13: Unknown, $f12: Unknown} }
id9($f12, $f13):>> New(id1: ($f1 -> $f12, $f2 -> $f13), id2: (), [])
 - New(id1: ($f1 -> $f12, $f2 -> $f13), id2: (), [])

(compose <(new (pred <(var $f33) (var $f34)>) (true) <>) (new (pred <(var $f33) (var $f34)>) (true) <(compose <(new (pred <(var $f33) (var $f34)>) (true) <(compose <(new (pred <(var $f33)>) (true) <>)>) (compose <(new (pred <(var $f34)>) (true) <>)>)>)>) (compose <(new (pred <(var $f33)>) (true) <>)>)>)>)
CHCData { predNames: {}, varTypes: {$f34: Unknown, $f33: Unknown} }
id13($f33, $f34):>> Compose([AppliedId(id9: ($f12 -> $f33, $f13 -> $f34)), AppliedId(id8: ($f10 -> $f33, $f11 -> $f34))])
 - Compose([AppliedId(id8: ($f10 -> $f33, $f11 -> $f34)), AppliedId(id9: ($f12 -> $f33, $f13 -> $f34))])
 - Compose([AppliedId(id9: ($f12 -> $f33, $f13 -> $f34)), AppliedId(id8: ($f10 -> $f33, $f11 -> $f34))])
[slotted_egraphs::parse] from (compose <(new (pred <?a ?b>) (true) <(compose <(new (pred <?a>) (true) <>)>) (compose <(new (pred <?b>) (true) <>)>) (compose <(new (pred <?a>) (true) <>)>)>) (new (pred <?a ?b>) (true) <>)>)
[slotted_egraphs::parse] to tokens [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, PVar("a"), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, PVar("b"), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, PVar("a"), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("new"), LParen, Ident("pred"), LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = (compose <(new (pred <?a ?b>) (true) <(compose <(new (pred <?a>) (true) <>)>) (compose <(new (pred <?b>) (true) <>)>) (compose <(new (pred <?a>) (true) <>)>)>) (new (pred <?a ?b>) (true) <>)>)

thread 'chc::tst::tst1' panicked at tests/chc/tst.rs:64:9:
assertion failed: resultLen > 0
stack backtrace:
   0: __rustc::rust_begin_unwind
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/panicking.rs:697:5
   1: core::panicking::panic_fmt
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/panicking.rs:75:14
   2: core::panicking::panic
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/panicking.rs:145:5
   3: entry::chc::tst::tst1
             at ./tests/chc/tst.rs:64:9
   4: entry::chc::tst::tst1::{{closure}}
             at ./tests/chc/tst.rs:39:10
   5: core::ops::function::FnOnce::call_once
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
   6: core::ops::function::FnOnce::call_once
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
test chc::tst::tst1 ... FAILED

failures:

failures:
    chc::tst::tst1

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 73 filtered out; finished in 0.05s

error: test failed, to rerun pass `--test entry`

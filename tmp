warning: unreachable expression
  --> src/lang.rs:77:17
   |
73 | /                 panic!(
74 | |                     "(Pond) slotted_egraphs::lang::AppliedId::from_syntax: expected a single applied id, got {:?}",
75 | |                     elems
76 | |                 );
   | |_________________- any code following this expression is unreachable
77 |                   None
   |                   ^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` on by default

warning: unreachable expression
   --> src/lang.rs:122:17
    |
118 | /                 panic!(
119 | |                     "(Pond) slotted_egraphs::slot::Slot::from_syntax: expected a single slot, got {:?}",
120 | |                     elems
121 | |                 );
    | |_________________- any code following this expression is unreachable
122 |                   None
    |                   ^^^^ unreachable expression

warning: unreachable expression
   --> src/lang.rs:156:25
    |
156 |                           None
    |                           ^^^^ unreachable expression
...
167 | / bare_language_child!(
168 | |     u128, u64, u32, u16, u8, i128, i64, i32, i16, i8, usize, isize, bool, char, Symbol, String
169 | | );
    | | -
    | | |
    | |_any code following this expression is unreachable
    |   in this macro invocation
    |
    = note: this warning originates in the macro `bare_language_child` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unreachable statement
   --> src/lang.rs:222:13
    |
218 | /             panic!(
219 | |                 "(Pond) slotted_egraphs::lang::Bind::from_syntax: expected a single slot, got {:?}",
220 | |                 elems
221 | |             );
    | |_____________- any code following this expression is unreachable
222 |               return None;
    |               ^^^^^^^^^^^^ unreachable statement

warning: unused variable: `v`
  --> src/debug.rs:67:41
   |
67 |                         SyntaxElem::Vec(v) => {
   |                                         ^ help: if this is intentional, prefix it with an underscore: `_v`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: `slotted-egraphs` (lib) generated 20 warnings (15 duplicates)
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Let(a0, a1))
}, "add" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Add(a0, a1))
}, "mul" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Mul(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: Let(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Rise :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Rise :: Let(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Var :: F(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: F(a0, a1))
}, "g" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: G(a0, a1))
}, "h" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: H(a0, a1))
}
from_syntax_arms1 = "lambda" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Lam(a0))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Var(a0))
}, "sing" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sing(a0, a1))
}, "sum" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind < Bind <
        AppliedId > > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sum(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Lam(a0, a1))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(ArrayLang :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Let(a0, a1))
}
from_syntax_arms1 = "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Var(a0))
}, "pred" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < Slot > >
        :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(CHC :: Pred(a0, a1))
}, "new" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a2 = tmp ? ; println!
    ("fields: {:?}", a2); children = rest; Some(CHC :: New(a0, a1, a2))
}, "compose" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Compose(a0))
}, "true" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; Some(CHC :: True())
}, "false" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; Some(CHC :: False())
}
warning: ambiguous glob re-exports
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^ the name `get_all_rewrites` in the value namespace is first re-exported here
...
26 | pub use chc::*;
   |         ------ but the name `get_all_rewrites` in the value namespace is also re-exported here
   |
   = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:14:27
   |
14 |     assert_reaches(a, b, &get_all_rewrites()[..], 3);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
   = note: `#[warn(ambiguous_glob_imports)]` on by default

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:28:27
   |
28 |     assert_reaches(a, b, &get_all_rewrites()[..], 2);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:42:27
   |
42 |     assert_reaches(a, b, &get_all_rewrites()[..], 3);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:55:27
   |
55 |     assert_reaches(a, b, &get_all_rewrites()[..], 10);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:79:27
   |
79 |     assert_reaches(a, b, &get_all_rewrites()[..], 10);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `slotted-egraphs` (test "entry") generated 6 warnings
warning: `slotted-egraphs` (lib test) generated 20 warnings (20 duplicates)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.18s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-da51ac60e9e03fa4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-1795150ff3165311)

running 1 test

s = "(compose <(new (pred P <$0 $1>) (true) <(compose <(new (pred Q <$0 $1>) (true) <(compose <(new (pred R1 <$0>) (true) <>)>) (compose <(new (pred R2 <$1>) (true) <>)>)>)>)>)>)"
tokenize: ret = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("pred"), Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [Ident("P"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
second case
from_syntax::elems = [String("P")]
L(Bare)::from_syntax with elems = [String("P")]
node2 = Some(PredName("P"))
from_syntax::elems = [String("P")]
L(Bare)::from_syntax with elems = [String("P")]
parse_pattern_nosubst ret3 = ENode(PredName("P"), [])
parse_pattern pat_struct = ENode(
    PredName(
        "P",
    ),
    [],
), pat_display = P
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(PredName("P"), [])), [LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
parse_nested_syntax_elem input tok = [Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem ret1 = Vec([Slot($0), Slot($1)])
syntax_elems_mock = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
from_syntax::elems = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
children: [AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($0), Slot($1)])]
tmp = Some([$0, $1])
fields: [$0, $1]
from_syntax::ret = Some(Pred(id0, map-[], [$0, $1]))
node1 = Some(Pred(id0, map-[], [$0, $1]))
from_syntax::elems = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
children: [AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($0), Slot($1)])]
tmp = Some([$0, $1])
fields: [$0, $1]
from_syntax::ret = Some(Pred(id0, map-[], [$0, $1]))
node = Pred(id0, map-[], [$0, $1])
before syntax_elems = [String("pred"), Pattern(ENode(PredName("P"), [])), Vec([Slot($0), Slot($1)])]
transformed syntax_elems = [ENode(PredName("P"), [])]
parse_pattern_nosubst ret2 = ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])])
parse_pattern pat_struct = ENode(
    Pred(
        id0, map-[],
        [
            $0,
            $1,
        ],
    ),
    [
        ENode(
            PredName(
                "P",
            ),
            [],
        ),
    ],
), pat_display = (pred P $0 $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])])), [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
syntax_elems_mock = [String("true")]
from_syntax::elems = [String("true")]
children: []
from_syntax::ret = Some(True)
node1 = Some(True)
from_syntax::elems = [String("true")]
children: []
from_syntax::ret = Some(True)
node = True
before syntax_elems = [String("true")]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(True, [])
parse_pattern pat_struct = ENode(
    True,
    [],
), pat_display = true
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(True, [])), [LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("pred"), Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [Ident("Q"), LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
second case
from_syntax::elems = [String("Q")]
L(Bare)::from_syntax with elems = [String("Q")]
node2 = Some(PredName("Q"))
from_syntax::elems = [String("Q")]
L(Bare)::from_syntax with elems = [String("Q")]
parse_pattern_nosubst ret3 = ENode(PredName("Q"), [])
parse_pattern pat_struct = ENode(
    PredName(
        "Q",
    ),
    [],
), pat_display = Q
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(PredName("Q"), [])), [LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LVecBracket, Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($0), Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
parse_nested_syntax_elem input tok = [Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem ret1 = Vec([Slot($0), Slot($1)])
syntax_elems_mock = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
from_syntax::elems = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
children: [AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($0), Slot($1)])]
tmp = Some([$0, $1])
fields: [$0, $1]
from_syntax::ret = Some(Pred(id0, map-[], [$0, $1]))
node1 = Some(Pred(id0, map-[], [$0, $1]))
from_syntax::elems = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
children: [AppliedId(id0, map-[]), Vec([Slot($0), Slot($1)])]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($0), Slot($1)])]
tmp = Some([$0, $1])
fields: [$0, $1]
from_syntax::ret = Some(Pred(id0, map-[], [$0, $1]))
node = Pred(id0, map-[], [$0, $1])
before syntax_elems = [String("pred"), Pattern(ENode(PredName("Q"), [])), Vec([Slot($0), Slot($1)])]
transformed syntax_elems = [ENode(PredName("Q"), [])]
parse_pattern_nosubst ret2 = ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])])
parse_pattern pat_struct = ENode(
    Pred(
        id0, map-[],
        [
            $0,
            $1,
        ],
    ),
    [
        ENode(
            PredName(
                "Q",
            ),
            [],
        ),
    ],
), pat_display = (pred Q $0 $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])])), [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("true"), RParen, LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
syntax_elems_mock = [String("true")]
from_syntax::elems = [String("true")]
children: []
from_syntax::ret = Some(True)
node1 = Some(True)
from_syntax::elems = [String("true")]
children: []
from_syntax::ret = Some(True)
node = True
before syntax_elems = [String("true")]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(True, [])
parse_pattern pat_struct = ENode(
    True,
    [],
), pat_display = true
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(True, [])), [LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("pred"), Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [Ident("R1"), LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
second case
from_syntax::elems = [String("R1")]
L(Bare)::from_syntax with elems = [String("R1")]
node2 = Some(PredName("R1"))
from_syntax::elems = [String("R1")]
L(Bare)::from_syntax with elems = [String("R1")]
parse_pattern_nosubst ret3 = ENode(PredName("R1"), [])
parse_pattern pat_struct = ENode(
    PredName(
        "R1",
    ),
    [],
), pat_display = R1
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(PredName("R1"), [])), [LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LVecBracket, Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
parse_nested_syntax_elem ret1 = Vec([Slot($0)])
syntax_elems_mock = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($0)])]
from_syntax::elems = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($0)])]
children: [AppliedId(id0, map-[]), Vec([Slot($0)])]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($0)])]
tmp = Some([$0])
fields: [$0]
from_syntax::ret = Some(Pred(id0, map-[], [$0]))
node1 = Some(Pred(id0, map-[], [$0]))
from_syntax::elems = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($0)])]
children: [AppliedId(id0, map-[]), Vec([Slot($0)])]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($0)])]
tmp = Some([$0])
fields: [$0]
from_syntax::ret = Some(Pred(id0, map-[], [$0]))
node = Pred(id0, map-[], [$0])
before syntax_elems = [String("pred"), Pattern(ENode(PredName("R1"), [])), Vec([Slot($0)])]
transformed syntax_elems = [ENode(PredName("R1"), [])]
parse_pattern_nosubst ret2 = ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])])
parse_pattern pat_struct = ENode(
    Pred(
        id0, map-[],
        [
            $0,
        ],
    ),
    [
        ENode(
            PredName(
                "R1",
            ),
            [],
        ),
    ],
), pat_display = (pred R1 $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])])), [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
syntax_elems_mock = [String("true")]
from_syntax::elems = [String("true")]
children: []
from_syntax::ret = Some(True)
node1 = Some(True)
from_syntax::elems = [String("true")]
children: []
from_syntax::ret = Some(True)
node = True
before syntax_elems = [String("true")]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(True, [])
parse_pattern pat_struct = ENode(
    True,
    [],
), pat_display = true
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(True, [])), [LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LVecBracket, RVecBracket, RParen, RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret1 = Vec([])
syntax_elems_mock = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
from_syntax::elems = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([])]
tmp = Some([])
fields: []
from_syntax::ret = Some(New(id0, map-[], id0, map-[], []))
node1 = Some(New(id0, map-[], id0, map-[], []))
from_syntax::elems = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([])]
tmp = Some([])
fields: []
from_syntax::ret = Some(New(id0, map-[], id0, map-[], []))
node = New(id0, map-[], id0, map-[], [])
before syntax_elems = [String("new"), Pattern(ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])])), Pattern(ENode(True, [])), Vec([])]
transformed syntax_elems = [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])]
parse_pattern_nosubst ret2 = ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])
parse_pattern pat_struct = ENode(
    New(
        id0, map-[],
        id0, map-[],
        [],
    ),
    [
        ENode(
            Pred(
                id0, map-[],
                [
                    $0,
                ],
            ),
            [
                ENode(
                    PredName(
                        "R1",
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            True,
            [],
        ),
    ],
), pat_display = (new (pred R1 $0) true)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])), [RVecBracket, RParen, LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])]))])
syntax_elems_mock = [String("compose"), Vec([AppliedId(id0, map-[])])]
from_syntax::elems = [String("compose"), Vec([AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(Compose([id0, map-[]]))
node1 = Some(Compose([id0, map-[]]))
from_syntax::elems = [String("compose"), Vec([AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(Compose([id0, map-[]]))
node = Compose([id0, map-[]])
before syntax_elems = [String("compose"), Vec([Pattern(ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])]))])]
transformed syntax_elems = [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]
parse_pattern_nosubst ret2 = ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])])
parse_pattern pat_struct = ENode(
    Compose(
        [
            id0, map-[],
        ],
    ),
    [
        ENode(
            New(
                id0, map-[],
                id0, map-[],
                [],
            ),
            [
                ENode(
                    Pred(
                        id0, map-[],
                        [
                            $0,
                        ],
                    ),
                    [
                        ENode(
                            PredName(
                                "R1",
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    True,
                    [],
                ),
            ],
        ),
    ],
), pat_display = (compose (new (pred R1 $0) true))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])])), [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("compose"), LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("new"), LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("pred"), Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [Ident("R2"), LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
second case
from_syntax::elems = [String("R2")]
L(Bare)::from_syntax with elems = [String("R2")]
node2 = Some(PredName("R2"))
from_syntax::elems = [String("R2")]
L(Bare)::from_syntax with elems = [String("R2")]
parse_pattern_nosubst ret3 = ENode(PredName("R2"), [])
parse_pattern pat_struct = ENode(
    PredName(
        "R2",
    ),
    [],
), pat_display = R2
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(PredName("R2"), [])), [LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LVecBracket, Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RVecBracket, RParen, LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem ret1 = Vec([Slot($1)])
syntax_elems_mock = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($1)])]
from_syntax::elems = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($1)])]
children: [AppliedId(id0, map-[]), Vec([Slot($1)])]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($1)])]
tmp = Some([$1])
fields: [$1]
from_syntax::ret = Some(Pred(id0, map-[], [$1]))
node1 = Some(Pred(id0, map-[], [$1]))
from_syntax::elems = [String("pred"), AppliedId(id0, map-[]), Vec([Slot($1)])]
children: [AppliedId(id0, map-[]), Vec([Slot($1)])]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($1)])]
tmp = Some([$1])
fields: [$1]
from_syntax::ret = Some(Pred(id0, map-[], [$1]))
node = Pred(id0, map-[], [$1])
before syntax_elems = [String("pred"), Pattern(ENode(PredName("R2"), [])), Vec([Slot($1)])]
transformed syntax_elems = [ENode(PredName("R2"), [])]
parse_pattern_nosubst ret2 = ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])])
parse_pattern pat_struct = ENode(
    Pred(
        id0, map-[],
        [
            $1,
        ],
    ),
    [
        ENode(
            PredName(
                "R2",
            ),
            [],
        ),
    ],
), pat_display = (pred R2 $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])])), [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("true"), RParen, LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
syntax_elems_mock = [String("true")]
from_syntax::elems = [String("true")]
children: []
from_syntax::ret = Some(True)
node1 = Some(True)
from_syntax::elems = [String("true")]
children: []
from_syntax::ret = Some(True)
node = True
before syntax_elems = [String("true")]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(True, [])
parse_pattern pat_struct = ENode(
    True,
    [],
), pat_display = true
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(True, [])), [LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LVecBracket, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret1 = Vec([])
syntax_elems_mock = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
from_syntax::elems = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([])]
tmp = Some([])
fields: []
from_syntax::ret = Some(New(id0, map-[], id0, map-[], []))
node1 = Some(New(id0, map-[], id0, map-[], []))
from_syntax::elems = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([])]
tmp = Some([])
fields: []
from_syntax::ret = Some(New(id0, map-[], id0, map-[], []))
node = New(id0, map-[], id0, map-[], [])
before syntax_elems = [String("new"), Pattern(ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])])), Pattern(ENode(True, [])), Vec([])]
transformed syntax_elems = [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])]
parse_pattern_nosubst ret2 = ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])
parse_pattern pat_struct = ENode(
    New(
        id0, map-[],
        id0, map-[],
        [],
    ),
    [
        ENode(
            Pred(
                id0, map-[],
                [
                    $1,
                ],
            ),
            [
                ENode(
                    PredName(
                        "R2",
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            True,
            [],
        ),
    ],
), pat_display = (new (pred R2 $1) true)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])), [RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])]))])
syntax_elems_mock = [String("compose"), Vec([AppliedId(id0, map-[])])]
from_syntax::elems = [String("compose"), Vec([AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(Compose([id0, map-[]]))
node1 = Some(Compose([id0, map-[]]))
from_syntax::elems = [String("compose"), Vec([AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(Compose([id0, map-[]]))
node = Compose([id0, map-[]])
before syntax_elems = [String("compose"), Vec([Pattern(ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])]))])]
transformed syntax_elems = [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])]
parse_pattern_nosubst ret2 = ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])
parse_pattern pat_struct = ENode(
    Compose(
        [
            id0, map-[],
        ],
    ),
    [
        ENode(
            New(
                id0, map-[],
                id0, map-[],
                [],
            ),
            [
                ENode(
                    Pred(
                        id0, map-[],
                        [
                            $1,
                        ],
                    ),
                    [
                        ENode(
                            PredName(
                                "R2",
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    True,
                    [],
                ),
            ],
        ),
    ],
), pat_display = (compose (new (pred R2 $1) true))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])), [RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])])), Pattern(ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])]))])
syntax_elems_mock = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]))
node1 = Some(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]))
from_syntax::elems = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]))
node = New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]])
before syntax_elems = [String("new"), Pattern(ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])])), Pattern(ENode(True, [])), Vec([Pattern(ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])])), Pattern(ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])]))])]
transformed syntax_elems = [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])]
parse_pattern_nosubst ret2 = ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])
parse_pattern pat_struct = ENode(
    New(
        id0, map-[],
        id0, map-[],
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        ENode(
            Pred(
                id0, map-[],
                [
                    $0,
                    $1,
                ],
            ),
            [
                ENode(
                    PredName(
                        "Q",
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            True,
            [],
        ),
        ENode(
            Compose(
                [
                    id0, map-[],
                ],
            ),
            [
                ENode(
                    New(
                        id0, map-[],
                        id0, map-[],
                        [],
                    ),
                    [
                        ENode(
                            Pred(
                                id0, map-[],
                                [
                                    $0,
                                ],
                            ),
                            [
                                ENode(
                                    PredName(
                                        "R1",
                                    ),
                                    [],
                                ),
                            ],
                        ),
                        ENode(
                            True,
                            [],
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Compose(
                [
                    id0, map-[],
                ],
            ),
            [
                ENode(
                    New(
                        id0, map-[],
                        id0, map-[],
                        [],
                    ),
                    [
                        ENode(
                            Pred(
                                id0, map-[],
                                [
                                    $1,
                                ],
                            ),
                            [
                                ENode(
                                    PredName(
                                        "R2",
                                    ),
                                    [],
                                ),
                            ],
                        ),
                        ENode(
                            True,
                            [],
                        ),
                    ],
                ),
            ],
        ),
    ],
), pat_display = (new (pred Q $0 $1) true (compose (new (pred R1 $0) true)) (compose (new (pred R2 $1) true)))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])), [RVecBracket, RParen, RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])]))])
syntax_elems_mock = [String("compose"), Vec([AppliedId(id0, map-[])])]
from_syntax::elems = [String("compose"), Vec([AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(Compose([id0, map-[]]))
node1 = Some(Compose([id0, map-[]]))
from_syntax::elems = [String("compose"), Vec([AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(Compose([id0, map-[]]))
node = Compose([id0, map-[]])
before syntax_elems = [String("compose"), Vec([Pattern(ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])]))])]
transformed syntax_elems = [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])]
parse_pattern_nosubst ret2 = ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])
parse_pattern pat_struct = ENode(
    Compose(
        [
            id0, map-[],
        ],
    ),
    [
        ENode(
            New(
                id0, map-[],
                id0, map-[],
                [
                    id0, map-[],
                    id0, map-[],
                ],
            ),
            [
                ENode(
                    Pred(
                        id0, map-[],
                        [
                            $0,
                            $1,
                        ],
                    ),
                    [
                        ENode(
                            PredName(
                                "Q",
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    True,
                    [],
                ),
                ENode(
                    Compose(
                        [
                            id0, map-[],
                        ],
                    ),
                    [
                        ENode(
                            New(
                                id0, map-[],
                                id0, map-[],
                                [],
                            ),
                            [
                                ENode(
                                    Pred(
                                        id0, map-[],
                                        [
                                            $0,
                                        ],
                                    ),
                                    [
                                        ENode(
                                            PredName(
                                                "R1",
                                            ),
                                            [],
                                        ),
                                    ],
                                ),
                                ENode(
                                    True,
                                    [],
                                ),
                            ],
                        ),
                    ],
                ),
                ENode(
                    Compose(
                        [
                            id0, map-[],
                        ],
                    ),
                    [
                        ENode(
                            New(
                                id0, map-[],
                                id0, map-[],
                                [],
                            ),
                            [
                                ENode(
                                    Pred(
                                        id0, map-[],
                                        [
                                            $1,
                                        ],
                                    ),
                                    [
                                        ENode(
                                            PredName(
                                                "R2",
                                            ),
                                            [],
                                        ),
                                    ],
                                ),
                                ENode(
                                    True,
                                    [],
                                ),
                            ],
                        ),
                    ],
                ),
            ],
        ),
    ],
), pat_display = (compose (new (pred Q $0 $1) true (compose (new (pred R1 $0) true)) (compose (new (pred R2 $1) true))))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])), [RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])]))])
syntax_elems_mock = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[])])]
from_syntax::elems = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[])])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[])])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(New(id0, map-[], id0, map-[], [id0, map-[]]))
node1 = Some(New(id0, map-[], id0, map-[], [id0, map-[]]))
from_syntax::elems = [String("new"), AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[])])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), Vec([AppliedId(id0, map-[])])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(New(id0, map-[], id0, map-[], [id0, map-[]]))
node = New(id0, map-[], id0, map-[], [id0, map-[]])
before syntax_elems = [String("new"), Pattern(ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])])), Pattern(ENode(True, [])), Vec([Pattern(ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])]))])]
transformed syntax_elems = [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])]
parse_pattern_nosubst ret2 = ENode(New(id0, map-[], id0, map-[], [id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])])
parse_pattern pat_struct = ENode(
    New(
        id0, map-[],
        id0, map-[],
        [
            id0, map-[],
        ],
    ),
    [
        ENode(
            Pred(
                id0, map-[],
                [
                    $0,
                    $1,
                ],
            ),
            [
                ENode(
                    PredName(
                        "P",
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            True,
            [],
        ),
        ENode(
            Compose(
                [
                    id0, map-[],
                ],
            ),
            [
                ENode(
                    New(
                        id0, map-[],
                        id0, map-[],
                        [
                            id0, map-[],
                            id0, map-[],
                        ],
                    ),
                    [
                        ENode(
                            Pred(
                                id0, map-[],
                                [
                                    $0,
                                    $1,
                                ],
                            ),
                            [
                                ENode(
                                    PredName(
                                        "Q",
                                    ),
                                    [],
                                ),
                            ],
                        ),
                        ENode(
                            True,
                            [],
                        ),
                        ENode(
                            Compose(
                                [
                                    id0, map-[],
                                ],
                            ),
                            [
                                ENode(
                                    New(
                                        id0, map-[],
                                        id0, map-[],
                                        [],
                                    ),
                                    [
                                        ENode(
                                            Pred(
                                                id0, map-[],
                                                [
                                                    $0,
                                                ],
                                            ),
                                            [
                                                ENode(
                                                    PredName(
                                                        "R1",
                                                    ),
                                                    [],
                                                ),
                                            ],
                                        ),
                                        ENode(
                                            True,
                                            [],
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ENode(
                            Compose(
                                [
                                    id0, map-[],
                                ],
                            ),
                            [
                                ENode(
                                    New(
                                        id0, map-[],
                                        id0, map-[],
                                        [],
                                    ),
                                    [
                                        ENode(
                                            Pred(
                                                id0, map-[],
                                                [
                                                    $1,
                                                ],
                                            ),
                                            [
                                                ENode(
                                                    PredName(
                                                        "R2",
                                                    ),
                                                    [],
                                                ),
                                            ],
                                        ),
                                        ENode(
                                            True,
                                            [],
                                        ),
                                    ],
                                ),
                            ],
                        ),
                    ],
                ),
            ],
        ),
    ],
), pat_display = (new (pred P $0 $1) true (compose (new (pred Q $0 $1) true (compose (new (pred R1 $0) true)) (compose (new (pred R2 $1) true)))))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(New(id0, map-[], id0, map-[], [id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])])), [RVecBracket, RParen]))
parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(New(id0, map-[], id0, map-[], [id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])]))])
syntax_elems_mock = [String("compose"), Vec([AppliedId(id0, map-[])])]
from_syntax::elems = [String("compose"), Vec([AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(Compose([id0, map-[]]))
node1 = Some(Compose([id0, map-[]]))
from_syntax::elems = [String("compose"), Vec([AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
tmp = Some([id0, map-[]])
fields: [id0, map-[]]
from_syntax::ret = Some(Compose([id0, map-[]]))
node = Compose([id0, map-[]])
before syntax_elems = [String("compose"), Vec([Pattern(ENode(New(id0, map-[], id0, map-[], [id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])]))])]
transformed syntax_elems = [ENode(New(id0, map-[], id0, map-[], [id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])])]
parse_pattern_nosubst ret2 = ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])])])
parse_pattern pat_struct = ENode(
    Compose(
        [
            id0, map-[],
        ],
    ),
    [
        ENode(
            New(
                id0, map-[],
                id0, map-[],
                [
                    id0, map-[],
                ],
            ),
            [
                ENode(
                    Pred(
                        id0, map-[],
                        [
                            $0,
                            $1,
                        ],
                    ),
                    [
                        ENode(
                            PredName(
                                "P",
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    True,
                    [],
                ),
                ENode(
                    Compose(
                        [
                            id0, map-[],
                        ],
                    ),
                    [
                        ENode(
                            New(
                                id0, map-[],
                                id0, map-[],
                                [
                                    id0, map-[],
                                    id0, map-[],
                                ],
                            ),
                            [
                                ENode(
                                    Pred(
                                        id0, map-[],
                                        [
                                            $0,
                                            $1,
                                        ],
                                    ),
                                    [
                                        ENode(
                                            PredName(
                                                "Q",
                                            ),
                                            [],
                                        ),
                                    ],
                                ),
                                ENode(
                                    True,
                                    [],
                                ),
                                ENode(
                                    Compose(
                                        [
                                            id0, map-[],
                                        ],
                                    ),
                                    [
                                        ENode(
                                            New(
                                                id0, map-[],
                                                id0, map-[],
                                                [],
                                            ),
                                            [
                                                ENode(
                                                    Pred(
                                                        id0, map-[],
                                                        [
                                                            $0,
                                                        ],
                                                    ),
                                                    [
                                                        ENode(
                                                            PredName(
                                                                "R1",
                                                            ),
                                                            [],
                                                        ),
                                                    ],
                                                ),
                                                ENode(
                                                    True,
                                                    [],
                                                ),
                                            ],
                                        ),
                                    ],
                                ),
                                ENode(
                                    Compose(
                                        [
                                            id0, map-[],
                                        ],
                                    ),
                                    [
                                        ENode(
                                            New(
                                                id0, map-[],
                                                id0, map-[],
                                                [],
                                            ),
                                            [
                                                ENode(
                                                    Pred(
                                                        id0, map-[],
                                                        [
                                                            $1,
                                                        ],
                                                    ),
                                                    [
                                                        ENode(
                                                            PredName(
                                                                "R2",
                                                            ),
                                                            [],
                                                        ),
                                                    ],
                                                ),
                                                ENode(
                                                    True,
                                                    [],
                                                ),
                                            ],
                                        ),
                                    ],
                                ),
                            ],
                        ),
                    ],
                ),
            ],
        ),
    ],
), pat_display = (compose (new (pred P $0 $1) true (compose (new (pred Q $0 $1) true (compose (new (pred R1 $0) true)) (compose (new (pred R2 $1) true))))))
pattern_to_re input pat = ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])])])
pattern_to_re input pat = ENode(New(id0, map-[], id0, map-[], [id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])])
pattern_to_re input pat = ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])])
pattern_to_re input pat = ENode(PredName("P"), [])
pattern_to_re input pat = ENode(True, [])
pattern_to_re input pat = ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])
pattern_to_re input pat = ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])
pattern_to_re input pat = ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])])
pattern_to_re input pat = ENode(PredName("Q"), [])
pattern_to_re input pat = ENode(True, [])
pattern_to_re input pat = ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])])
pattern_to_re input pat = ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])
pattern_to_re input pat = ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])])
pattern_to_re input pat = ENode(PredName("R1"), [])
pattern_to_re input pat = ENode(True, [])
pattern_to_re input pat = ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])
pattern_to_re input pat = ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])
pattern_to_re input pat = ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])])
pattern_to_re input pat = ENode(PredName("R2"), [])
pattern_to_re input pat = ENode(True, [])
RecExpr::parse: ret = ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("P"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], [id0, map-[], id0, map-[]]), [ENode(Pred(id0, map-[], [$0, $1]), [ENode(PredName("Q"), [])]), ENode(True, []), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$0]), [ENode(PredName("R1"), [])]), ENode(True, [])])]), ENode(Compose([id0, map-[]]), [ENode(New(id0, map-[], id0, map-[], []), [ENode(Pred(id0, map-[], [$1]), [ENode(PredName("R2"), [])]), ENode(True, [])])])])])])])


id0():
>> PredName("P")
 - PredName("P")

id1($f0, $f1):
>> Pred(id0, map-[], [$f0, $f1])
 - Pred(id0, map-[], [$f0, $f1])

id2():
>> True
 - True

id3():
>> PredName("Q")
 - PredName("Q")

id4($f2, $f3):
>> Pred(id3, map-[], [$f2, $f3])
 - Pred(id3, map-[], [$f2, $f3])

id5():
>> PredName("R1")
 - PredName("R1")

id6($f4):
>> Pred(id5, map-[], [$f4])
 - Pred(id5, map-[], [$f4])

id7($f5):
>> New(id6, map-[$f4 -> $f5], id2, map-[], [])
 - New(id6, map-[$f4 -> $f5], id2, map-[], [])

id8($f6):
>> Compose([id7, map-[$f5 -> $f6]])
 - Compose([id7, map-[$f5 -> $f6]])

id9():
>> PredName("R2")
 - PredName("R2")

id10($f7):
>> Pred(id9, map-[], [$f7])
 - Pred(id9, map-[], [$f7])

id11($f8):
>> New(id10, map-[$f7 -> $f8], id2, map-[], [])
 - New(id10, map-[$f7 -> $f8], id2, map-[], [])

id12($f9):
>> Compose([id11, map-[$f8 -> $f9]])
 - Compose([id11, map-[$f8 -> $f9]])

id13($f10, $f11):
>> New(id4, map-[$f2 -> $f10, $f3 -> $f11], id2, map-[], [id8, map-[$f6 -> $f10], id12, map-[$f9 -> $f11]])
 - New(id4, map-[$f2 -> $f10, $f3 -> $f11], id2, map-[], [id8, map-[$f6 -> $f10], id12, map-[$f9 -> $f11]])

id14($f12, $f13):
>> Compose([id13, map-[$f10 -> $f12, $f11 -> $f13]])
 - Compose([id13, map-[$f10 -> $f12, $f11 -> $f13]])

id15($f14, $f15):
>> New(id1, map-[$f0 -> $f14, $f1 -> $f15], id2, map-[], [id14, map-[$f12 -> $f14, $f13 -> $f15]])
 - New(id1, map-[$f0 -> $f14, $f1 -> $f15], id2, map-[], [id14, map-[$f12 -> $f14, $f13 -> $f15]])

id16($f16, $f17):
>> Compose([id15, map-[$f14 -> $f16, $f15 -> $f17]])
 - Compose([id15, map-[$f14 -> $f16, $f15 -> $f17]])

test chc::tst1 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 70 filtered out; finished in 0.01s


warning: unreachable expression
  --> src/lang.rs:79:17
   |
75 | /                 panic!(
76 | |                     "(Pond) slotted_egraphs::lang::AppliedId::from_syntax: expected a single applied id, got {:?}",
77 | |                     elems
78 | |                 );
   | |_________________- any code following this expression is unreachable
79 |                   None
   |                   ^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` on by default

warning: unreachable expression
   --> src/lang.rs:124:17
    |
120 | /                 panic!(
121 | |                     "(Pond) slotted_egraphs::slot::Slot::from_syntax: expected a single slot, got {:?}",
122 | |                     elems
123 | |                 );
    | |_________________- any code following this expression is unreachable
124 |                   None
    |                   ^^^^ unreachable expression

warning: unreachable expression
   --> src/lang.rs:158:25
    |
158 |                           None
    |                           ^^^^ unreachable expression
...
169 | / bare_language_child!(
170 | |     u128, u64, u32, u16, u8, i128, i64, i32, i16, i8, usize, isize, bool, char, Symbol, String
171 | | );
    | | -
    | | |
    | |_any code following this expression is unreachable
    |   in this macro invocation
    |
    = note: this warning originates in the macro `bare_language_child` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unreachable statement
   --> src/lang.rs:224:13
    |
220 | /             panic!(
221 | |                 "(Pond) slotted_egraphs::lang::Bind::from_syntax: expected a single slot, got {:?}",
222 | |                 elems
223 | |             );
    | |_____________- any code following this expression is unreachable
224 |               return None;
    |               ^^^^^^^^^^^^ unreachable statement

warning: unused variable: `v`
  --> src/debug.rs:67:41
   |
67 |                         SyntaxElem::Vec(v) => {
   |                                         ^ help: if this is intentional, prefix it with an underscore: `_v`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: `slotted-egraphs` (lib) generated 20 warnings (15 duplicates)
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Let(a0, a1))
}, "add" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Add(a0, a1))
}, "mul" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Mul(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: Let(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Rise :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Rise :: Let(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Var :: F(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: F(a0, a1))
}, "g" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: G(a0, a1))
}, "h" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: H(a0, a1))
}
from_syntax_arms1 = "lambda" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Lam(a0))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Var(a0))
}, "sing" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sing(a0, a1))
}, "sum" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind < Bind <
        AppliedId > > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sum(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Lam(a0, a1))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(ArrayLang :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Let(a0, a1))
}
from_syntax_arms1 = "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Var(a0))
}, "and" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(CHC :: And(a0))
}
warning: ambiguous glob re-exports
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^ the name `get_all_rewrites` in the value namespace is first re-exported here
...
26 | pub use chc::*;
   |         ------ but the name `get_all_rewrites` in the value namespace is also re-exported here
   |
   = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:14:27
   |
14 |     assert_reaches(a, b, &get_all_rewrites()[..], 3);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
   = note: `#[warn(ambiguous_glob_imports)]` on by default

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:28:27
   |
28 |     assert_reaches(a, b, &get_all_rewrites()[..], 2);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:42:27
   |
42 |     assert_reaches(a, b, &get_all_rewrites()[..], 3);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:55:27
   |
55 |     assert_reaches(a, b, &get_all_rewrites()[..], 10);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:79:27
   |
79 |     assert_reaches(a, b, &get_all_rewrites()[..], 10);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `slotted-egraphs` (test "entry") generated 6 warnings
warning: `slotted-egraphs` (lib test) generated 20 warnings (20 duplicates)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.15s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-1fd5cb9b334baebe)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-2536ed5f6f6e1d90)

running 1 test
[slotted_egraphs::parse] 
    s = "(and <?1 (and <?2 ?3>)>)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("1")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "1",
    ), pat_display = ?1
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("1")), [LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("2")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "2",
    ), pat_display = ?2
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("2")), [PVar("3"), RVecBracket, RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("3")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "3",
    ), pat_display = ?3
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("3")), [RVecBracket, RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("2")), Pattern(PVar("3"))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("2")), Pattern(PVar("3"))])]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("2"), PVar("3")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            PVar(
                "2",
            ),
            PVar(
                "3",
            ),
        ],
    ), pat_display = (and ?2 ?3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")])), [RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("1")), Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")]))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("1")), Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")]))])]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("1"), ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")])])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            PVar(
                "1",
            ),
            ENode(
                And(
                    [
                        id0, map-[],
                        id0, map-[],
                    ],
                ),
                [
                    PVar(
                        "2",
                    ),
                    PVar(
                        "3",
                    ),
                ],
            ),
        ],
    ), pat_display = (and ?1 (and ?2 ?3))
[slotted_egraphs::parse] 
    s = "(and <(and <?1 ?2>) ?3>)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("1")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "1",
    ), pat_display = ?1
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("1")), [PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("2")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "2",
    ), pat_display = ?2
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("2")), [RVecBracket, RParen, PVar("3"), RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("1")), Pattern(PVar("2"))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("1")), Pattern(PVar("2"))])]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("1"), PVar("2")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            PVar(
                "1",
            ),
            PVar(
                "2",
            ),
        ],
    ), pat_display = (and ?1 ?2)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")])), [PVar("3"), RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("3"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("3")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "3",
    ), pat_display = ?3
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("3")), [RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")])), Pattern(PVar("3"))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")])), Pattern(PVar("3"))])]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")]), PVar("3")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")]), PVar("3")])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            ENode(
                And(
                    [
                        id0, map-[],
                        id0, map-[],
                    ],
                ),
                [
                    PVar(
                        "1",
                    ),
                    PVar(
                        "2",
                    ),
                ],
            ),
            PVar(
                "3",
            ),
        ],
    ), pat_display = (and (and ?1 ?2) ?3)
[slotted_egraphs::parse] 
    s = "(and <?a ?b>)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("a")), Pattern(PVar("b"))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("a")), Pattern(PVar("b"))])]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (and ?a ?b)
[slotted_egraphs::parse] 
    s = "(and <?b ?a>)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("b"), PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("b")), Pattern(PVar("a"))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("b")), Pattern(PVar("a"))])]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("a")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("a")])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "a",
            ),
        ],
    ), pat_display = (and ?b ?a)
[slotted_egraphs::parse] 
    s = "(and <?a (and <?b ?c>)>)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RVecBracket, RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RVecBracket, RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("b")), Pattern(PVar("c"))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("b")), Pattern(PVar("c"))])]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (and ?b ?c)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")])), [RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("a")), Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")]))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("a")), Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")]))])]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("a"), ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")])])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                And(
                    [
                        id0, map-[],
                        id0, map-[],
                    ],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    ), pat_display = (and ?a (and ?b ?c))
[slotted_egraphs::parse] 
    s = "(and <?a ?b ?c>)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), PVar("c"), RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("a")), Pattern(PVar("b")), Pattern(PVar("c"))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("a")), Pattern(PVar("b")), Pattern(PVar("c"))])]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[], id0, map-[]]), [PVar("a"), PVar("b"), PVar("c")])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (and ?a ?b ?c)
[slotted_egraphs::parse] 
    s = "(and <(and <(var $0) (var $1)>) (var $2)>)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($0)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($0)]
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node1 = Some(Var($0))
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node = Var($0)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($0)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($0), [])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        Var(
            $0,
        ),
        [],
    ), pat_display = (var $0)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))])]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            ENode(
                Var(
                    $0,
                ),
                [],
            ),
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
        ],
    ), pat_display = (and (var $0) (var $1))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($2)]
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node1 = Some(Var($2))
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node = Var($2)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($2)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($2), [])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        Var(
            $2,
        ),
        [],
    ), pat_display = (var $2)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])])), Pattern(ENode(Var($2), []))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])])), Pattern(ENode(Var($2), []))])]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            ENode(
                And(
                    [
                        id0, map-[],
                        id0, map-[],
                    ],
                ),
                [
                    ENode(
                        Var(
                            $0,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $1,
                        ),
                        [],
                    ),
                ],
            ),
            ENode(
                Var(
                    $2,
                ),
                [],
            ),
        ],
    ), pat_display = (and (and (var $0) (var $1)) (var $2))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([id0, map-[], id0, map-[]]), [ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($0), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($1), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($2), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(And([id0, map-[], id0, map-[]]), [ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])
[slotted_egraphs::parse] 
    s = "(and <(var $0) (var $1) (var $2)>)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($0)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($0)]
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node1 = Some(Var($0))
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node = Var($0)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($0)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($0), [])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        Var(
            $0,
        ),
        [],
    ), pat_display = (var $0)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($2)]
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node1 = Some(Var($2))
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node = Var($2)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($2)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($2), [])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        Var(
            $2,
        ),
        [],
    ), pat_display = (var $2)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))])
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node1 = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[entry::chc] tmp = Some([id0, map-[], id0, map-[], id0, map-[]])
[entry::chc] fields: [id0, map-[], id0, map-[], id0, map-[]]
[entry::chc] from_syntax::ret = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
[slotted_egraphs::parse] node = And([id0, map-[], id0, map-[], id0, map-[]])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))])]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), [])])
[slotted_egraphs::parse] parse_pattern pat_struct = ENode(
        And(
            [
                id0, map-[],
                id0, map-[],
                id0, map-[],
            ],
        ),
        [
            ENode(
                Var(
                    $0,
                ),
                [],
            ),
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            ENode(
                Var(
                    $2,
                ),
                [],
            ),
        ],
    ), pat_display = (and (var $0) (var $1) (var $2))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([id0, map-[], id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($0), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($1), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($2), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(And([id0, map-[], id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), [])])
[tests/entry.rs:124:5] &report.stop_reason = Other(
    Reached,
)


id0($f0):
>> Var($f0)
 - Var($f0)

id1($f1, $f2):
>> And([id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2]])
 - And([id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2]])
 -- [$f1 -> $f2, $f2 -> $f1]

id3($f11, $f12, $f13):
>> And([id0, map-[$f0 -> $f13], id1, map-[$f1 -> $f12, $f2 -> $f11]])
 - And([id1, map-[$f1 -> $f11, $f2 -> $f12], id0, map-[$f0 -> $f13]])
 - And([id0, map-[$f0 -> $f13], id1, map-[$f1 -> $f11, $f2 -> $f12]])
 - And([id0, map-[$f0 -> $f13], id0, map-[$f0 -> $f12], id0, map-[$f0 -> $f11]])
 -- [$f11 -> $f13, $f12 -> $f11, $f13 -> $f12]
 -- [$f11 -> $f11, $f12 -> $f13, $f13 -> $f12]
 -- [$f11 -> $f12, $f12 -> $f11, $f13 -> $f13]

test chc::and ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 70 filtered out; finished in 0.03s


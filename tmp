   Compiling slotted-egraphs v0.0.36 (/home/pondnj/chc/project/slotted-egraphs)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 2.29s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-6d92e85151c62515)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-44c3f9e1ee7a5866)

running 1 test
[slotted_egraphs::parse] 
    s = "(app (lam $1 ?b) ?t)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("t"), RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
[slotted_egraphs::parse] node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
[entry::arith] from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
[slotted_egraphs::parse] node = Lam(Bind { slot: $1, elem: id0, map-[] })
[slotted_egraphs::parse] before syntax_elems = [String("lam"), Slot($1), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Lam(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
        ),
        [
            PVar(
                "b",
            ),
        ],
    ), pat_display = (lam $1 ?b)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), [PVar("t"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("t"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("t")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "t",
    ), pat_display = ?t
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(App(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = App(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("app"), Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("t"))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        App(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Lam(
                    Bind {
                        slot: $1,
                        elem: id0, map-[],
                    },
                ),
                [
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "t",
            ),
        ],
    ), pat_display = (app (lam $1 ?b) ?t)
[slotted_egraphs::parse] 
    s = "(let $1 ?b ?t)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("t"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("t")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "t",
    ), pat_display = ?t
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("t")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "t",
            ),
        ],
    ), pat_display = (let $1 ?b ?t)
[slotted_egraphs::parse] 
    s = "(lam $1 (app ?b (var $1)))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::arith] from_syntax::elems = [String("var"), Slot($1)]
[entry::arith] children: [Slot($1)]
[entry::arith] tmp = Some($1)
[entry::arith] fields: $1
[entry::arith] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::arith] from_syntax::elems = [String("var"), Slot($1)]
[entry::arith] children: [Slot($1)]
[entry::arith] tmp = Some($1)
[entry::arith] fields: $1
[entry::arith] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(App(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = App(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("app"), Pattern(PVar("b")), Pattern(ENode(Var($1), []))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), ENode(Var($1), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        App(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
        ],
    ), pat_display = (app ?b (var $1))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
[slotted_egraphs::parse] node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
[entry::arith] from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
[slotted_egraphs::parse] node = Lam(Bind { slot: $1, elem: id0, map-[] })
[slotted_egraphs::parse] before syntax_elems = [String("lam"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])]))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Lam(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
        ),
        [
            ENode(
                App(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    ENode(
                        Var(
                            $1,
                        ),
                        [],
                    ),
                ],
            ),
        ],
    ), pat_display = (lam $1 (app ?b (var $1)))
[slotted_egraphs::parse] 
    s = "?b"
[slotted_egraphs::parse] tokenize: ret = [PVar("b")]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] 
    s = "(let $1 ?b ?t)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("t"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("t"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("t")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "t",
    ), pat_display = ?t
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("t")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "t",
            ),
        ],
    ), pat_display = (let $1 ?b ?t)
[slotted_egraphs::parse] 
    s = "?b"
[slotted_egraphs::parse] tokenize: ret = [PVar("b")]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] 
    s = "(let $1 (var $1) ?e)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::arith] from_syntax::elems = [String("var"), Slot($1)]
[entry::arith] children: [Slot($1)]
[entry::arith] tmp = Some($1)
[entry::arith] fields: $1
[entry::arith] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::arith] from_syntax::elems = [String("var"), Slot($1)]
[entry::arith] children: [Slot($1)]
[entry::arith] tmp = Some($1)
[entry::arith] fields: $1
[entry::arith] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [PVar("e"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("e"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("e")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "e",
    ), pat_display = ?e
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Var($1), [])), Pattern(PVar("e"))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($1), []), PVar("e")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Var($1), []), PVar("e")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            PVar(
                "e",
            ),
        ],
    ), pat_display = (let $1 (var $1) ?e)
[slotted_egraphs::parse] 
    s = "?e"
[slotted_egraphs::parse] tokenize: ret = [PVar("e")]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("e")]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("e")]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("e")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "e",
    ), pat_display = ?e
[slotted_egraphs::parse] 
    s = "(let $1 (app ?a ?b) ?e)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("e"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(App(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = App(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("app"), Pattern(PVar("a")), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        App(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (app ?a ?b)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("e"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("e"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("e")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "e",
    ), pat_display = ?e
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("let"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("e"))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            ENode(
                App(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "e",
            ),
        ],
    ), pat_display = (let $1 (app ?a ?b) ?e)
[slotted_egraphs::parse] 
    s = "(app (let $1 ?a ?e) (let $1 ?b ?e))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("e")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "e",
    ), pat_display = ?e
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("let"), Slot($1), Pattern(PVar("a")), Pattern(PVar("e"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("e")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "e",
            ),
        ],
    ), pat_display = (let $1 ?a ?e)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("e")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "e",
    ), pat_display = ?e
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("e")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "e",
            ),
        ],
    ), pat_display = (let $1 ?b ?e)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(App(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = App(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("app"), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        App(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Let(
                    Bind {
                        slot: $1,
                        elem: id0, map-[],
                    },
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "e",
                    ),
                ],
            ),
            ENode(
                Let(
                    Bind {
                        slot: $1,
                        elem: id0, map-[],
                    },
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "e",
                    ),
                ],
            ),
        ],
    ), pat_display = (app (let $1 ?a ?e) (let $1 ?b ?e))
[slotted_egraphs::parse] 
    s = "(let $1 (lam $2 ?b) ?e)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($2), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $2, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $2, elem: id0, map-[] }
[entry::arith] from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
[slotted_egraphs::parse] node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
[entry::arith] from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($2), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $2, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $2, elem: id0, map-[] }
[entry::arith] from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
[slotted_egraphs::parse] node = Lam(Bind { slot: $2, elem: id0, map-[] })
[slotted_egraphs::parse] before syntax_elems = [String("lam"), Slot($2), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Lam(
            Bind {
                slot: $2,
                elem: id0, map-[],
            },
        ),
        [
            PVar(
                "b",
            ),
        ],
    ), pat_display = (lam $2 ?b)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), [PVar("e"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("e"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("e"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("e")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "e",
    ), pat_display = ?e
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("e"))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            ENode(
                Lam(
                    Bind {
                        slot: $2,
                        elem: id0, map-[],
                    },
                ),
                [
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "e",
            ),
        ],
    ), pat_display = (let $1 (lam $2 ?b) ?e)
[slotted_egraphs::parse] 
    s = "(lam $2 (let $1 ?b ?e))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("e")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "e",
    ), pat_display = ?e
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[entry::arith] from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $1, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $1, elem: id0, map-[] }
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
[slotted_egraphs::parse] node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("e")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "e",
            ),
        ],
    ), pat_display = (let $1 ?b ?e)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($2), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $2, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $2, elem: id0, map-[] }
[entry::arith] from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
[slotted_egraphs::parse] node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
[entry::arith] from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
[entry::arith] children: [Slot($2), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(Bind { slot: $2, elem: id0, map-[] })
[entry::arith] fields: Bind { slot: $2, elem: id0, map-[] }
[entry::arith] from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
[slotted_egraphs::parse] node = Lam(Bind { slot: $2, elem: id0, map-[] })
[slotted_egraphs::parse] before syntax_elems = [String("lam"), Slot($2), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Lam(
            Bind {
                slot: $2,
                elem: id0, map-[],
            },
        ),
        [
            ENode(
                Let(
                    Bind {
                        slot: $1,
                        elem: id0, map-[],
                    },
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "e",
                    ),
                ],
            ),
        ],
    ), pat_display = (lam $2 (let $1 ?b ?e))
[slotted_egraphs::parse] 
    s = "(add ?a ?b)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (add ?a ?b)
[slotted_egraphs::parse] 
    s = "(add ?b ?a)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("a"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("a")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "a",
            ),
        ],
    ), pat_display = (add ?b ?a)
[slotted_egraphs::parse] 
    s = "(add ?a (add ?b ?c))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (add ?b ?c)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    ), pat_display = (add ?a (add ?b ?c))
[slotted_egraphs::parse] 
    s = "(add (add ?a ?b) ?c)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (add ?a ?b)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (add (add ?a ?b) ?c)
[slotted_egraphs::parse] 
    s = "(add (add ?a ?b) ?c)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (add ?a ?b)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (add (add ?a ?b) ?c)
[slotted_egraphs::parse] 
    s = "(add ?a (add ?b ?c))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (add ?b ?c)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    ), pat_display = (add ?a (add ?b ?c))
[slotted_egraphs::parse] 
    s = "(mul ?a ?b)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (mul ?a ?b)
[slotted_egraphs::parse] 
    s = "(mul ?b ?a)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("a"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("a")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "a",
            ),
        ],
    ), pat_display = (mul ?b ?a)
[slotted_egraphs::parse] 
    s = "(mul ?a (mul ?b ?c))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (mul ?b ?c)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    ), pat_display = (mul ?a (mul ?b ?c))
[slotted_egraphs::parse] 
    s = "(mul (mul ?a ?b) ?c)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (mul ?a ?b)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (mul (mul ?a ?b) ?c)
[slotted_egraphs::parse] 
    s = "(mul (mul ?a ?b) ?c)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (mul ?a ?b)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (mul (mul ?a ?b) ?c)
[slotted_egraphs::parse] 
    s = "(mul ?a (mul ?b ?c))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (mul ?b ?c)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    ), pat_display = (mul ?a (mul ?b ?c))
[slotted_egraphs::parse] 
    s = "(mul ?a (add ?b ?c))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (add ?b ?c)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    ), pat_display = (mul ?a (add ?b ?c))
[slotted_egraphs::parse] 
    s = "(add (mul ?a ?b) (mul ?a ?c))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (mul ?a ?b)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (mul ?a ?c)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    ), pat_display = (add (mul ?a ?b) (mul ?a ?c))
[slotted_egraphs::parse] 
    s = "(add (mul ?a ?b) (mul ?a ?c))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (mul ?a ?b)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (mul ?a ?c)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    ), pat_display = (add (mul ?a ?b) (mul ?a ?c))
[slotted_egraphs::parse] 
    s = "(mul ?a (add ?b ?c))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("c")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "c",
    ), pat_display = ?c
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("b"), PVar("c")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "c",
            ),
        ],
    ), pat_display = (add ?b ?c)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    ), pat_display = (mul ?a (add ?b ?c))
[slotted_egraphs::parse] 
    s = "(mul (add (var $x) (var $y)) (add (var $x) (var $y)))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($x)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($x)]
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node1 = Some(Var($x))
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node = Var($x)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($x)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($x), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $x,
        ),
        [],
    ), pat_display = (var $x)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($y)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($y)]
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node1 = Some(Var($y))
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node = Var($y)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($y)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($y), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $y,
        ),
        [],
    ), pat_display = (var $y)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($y), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($x), []), ENode(Var($y), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $x,
                ),
                [],
            ),
            ENode(
                Var(
                    $y,
                ),
                [],
            ),
        ],
    ), pat_display = (add (var $x) (var $y))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($x)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($x)]
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node1 = Some(Var($x))
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node = Var($x)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($x)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($x), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $x,
        ),
        [],
    ), pat_display = (var $x)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($y)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($y)]
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node1 = Some(Var($y))
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node = Var($y)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($y)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($y), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $y,
        ),
        [],
    ), pat_display = (var $y)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($y), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($x), []), ENode(Var($y), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $x,
                ),
                [],
            ),
            ENode(
                Var(
                    $y,
                ),
                [],
            ),
        ],
    ), pat_display = (add (var $x) (var $y))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    ENode(
                        Var(
                            $x,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $y,
                        ),
                        [],
                    ),
                ],
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    ENode(
                        Var(
                            $x,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $y,
                        ),
                        [],
                    ),
                ],
            ),
        ],
    ), pat_display = (mul (add (var $x) (var $y)) (add (var $x) (var $y)))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($x), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($y), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($x), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($y), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])])
[slotted_egraphs::parse] 
    s = "(add (mul (var $x) (var $x))\n             (add (mul (var $x) (var $y))\n             (add (mul (var $x) (var $y))\n                  (mul (var $y) (var $y))\n             )))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($x)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($x)]
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node1 = Some(Var($x))
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node = Var($x)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($x)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($x), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $x,
        ),
        [],
    ), pat_display = (var $x)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($x)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($x)]
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node1 = Some(Var($x))
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node = Var($x)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($x)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($x), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $x,
        ),
        [],
    ), pat_display = (var $x)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($x), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($x), []), ENode(Var($x), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $x,
                ),
                [],
            ),
            ENode(
                Var(
                    $x,
                ),
                [],
            ),
        ],
    ), pat_display = (mul (var $x) (var $x))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])])), [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($x)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($x)]
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node1 = Some(Var($x))
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node = Var($x)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($x)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($x), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $x,
        ),
        [],
    ), pat_display = (var $x)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($y)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($y)]
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node1 = Some(Var($y))
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node = Var($y)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($y)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($y), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $y,
        ),
        [],
    ), pat_display = (var $y)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($y), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($x), []), ENode(Var($y), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $x,
                ),
                [],
            ),
            ENode(
                Var(
                    $y,
                ),
                [],
            ),
        ],
    ), pat_display = (mul (var $x) (var $y))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($x)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($x)]
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node1 = Some(Var($x))
[entry::arith] from_syntax::elems = [String("var"), Slot($x)]
[entry::arith] children: [Slot($x)]
[entry::arith] tmp = Some($x)
[entry::arith] fields: $x
[entry::arith] from_syntax::ret = Some(Var($x))
[slotted_egraphs::parse] node = Var($x)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($x)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($x), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $x,
        ),
        [],
    ), pat_display = (var $x)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($y)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($y)]
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node1 = Some(Var($y))
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node = Var($y)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($y)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($y), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $y,
        ),
        [],
    ), pat_display = (var $y)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($y), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($x), []), ENode(Var($y), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $x,
                ),
                [],
            ),
            ENode(
                Var(
                    $y,
                ),
                [],
            ),
        ],
    ), pat_display = (mul (var $x) (var $y))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($y)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($y)]
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node1 = Some(Var($y))
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node = Var($y)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($y)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($y), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $y,
        ),
        [],
    ), pat_display = (var $y)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, RParen, RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($y)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($y)]
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node1 = Some(Var($y))
[entry::arith] from_syntax::elems = [String("var"), Slot($y)]
[entry::arith] children: [Slot($y)]
[entry::arith] tmp = Some($y)
[entry::arith] fields: $y
[entry::arith] from_syntax::ret = Some(Var($y))
[slotted_egraphs::parse] node = Var($y)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($y)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($y), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $y,
        ),
        [],
    ), pat_display = (var $y)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, RParen, RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Mul(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Mul(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("mul"), Pattern(ENode(Var($y), [])), Pattern(ENode(Var($y), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($y), []), ENode(Var($y), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $y,
                ),
                [],
            ),
            ENode(
                Var(
                    $y,
                ),
                [],
            ),
        ],
    ), pat_display = (mul (var $y) (var $y))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])), [RParen, RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])]))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    ENode(
                        Var(
                            $x,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $y,
                        ),
                        [],
                    ),
                ],
            ),
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    ENode(
                        Var(
                            $y,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $y,
                        ),
                        [],
                    ),
                ],
            ),
        ],
    ), pat_display = (add (mul (var $x) (var $y)) (mul (var $y) (var $y)))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])), [RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])]))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    ENode(
                        Var(
                            $x,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $y,
                        ),
                        [],
                    ),
                ],
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    ENode(
                        Mul(
                            id0, map-[],
                            id0, map-[],
                        ),
                        [
                            ENode(
                                Var(
                                    $x,
                                ),
                                [],
                            ),
                            ENode(
                                Var(
                                    $y,
                                ),
                                [],
                            ),
                        ],
                    ),
                    ENode(
                        Mul(
                            id0, map-[],
                            id0, map-[],
                        ),
                        [
                            ENode(
                                Var(
                                    $y,
                                ),
                                [],
                            ),
                            ENode(
                                Var(
                                    $y,
                                ),
                                [],
                            ),
                        ],
                    ),
                ],
            ),
        ],
    ), pat_display = (add (mul (var $x) (var $y)) (add (mul (var $x) (var $y)) (mul (var $y) (var $y))))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(Add(id0, map-[], id0, map-[]))
[entry::arith] from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] tmp = Some(id0, map-[])
[entry::arith] fields: id0, map-[]
[entry::arith] from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
[slotted_egraphs::parse] node = Add(id0, map-[], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])]))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    ENode(
                        Var(
                            $x,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $x,
                        ),
                        [],
                    ),
                ],
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    ENode(
                        Mul(
                            id0, map-[],
                            id0, map-[],
                        ),
                        [
                            ENode(
                                Var(
                                    $x,
                                ),
                                [],
                            ),
                            ENode(
                                Var(
                                    $y,
                                ),
                                [],
                            ),
                        ],
                    ),
                    ENode(
                        Add(
                            id0, map-[],
                            id0, map-[],
                        ),
                        [
                            ENode(
                                Mul(
                                    id0, map-[],
                                    id0, map-[],
                                ),
                                [
                                    ENode(
                                        Var(
                                            $x,
                                        ),
                                        [],
                                    ),
                                    ENode(
                                        Var(
                                            $y,
                                        ),
                                        [],
                                    ),
                                ],
                            ),
                            ENode(
                                Mul(
                                    id0, map-[],
                                    id0, map-[],
                                ),
                                [
                                    ENode(
                                        Var(
                                            $y,
                                        ),
                                        [],
                                    ),
                                    ENode(
                                        Var(
                                            $y,
                                        ),
                                        [],
                                    ),
                                ],
                            ),
                        ],
                    ),
                ],
            ),
        ],
    ), pat_display = (add (mul (var $x) (var $x)) (add (mul (var $x) (var $y)) (add (mul (var $x) (var $y)) (mul (var $y) (var $y)))))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($x), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($x), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($x), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($y), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($x), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($y), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($y), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($y), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])])
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        App(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Lam(
                    Bind {
                        slot: $1,
                        elem: id0, map-[],
                    },
                ),
                [
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "t",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Lam(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
        ),
        [
            ENode(
                App(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    ENode(
                        Var(
                            $1,
                        ),
                        [],
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "t",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            PVar(
                "e",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            ENode(
                App(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "e",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            ENode(
                Lam(
                    Bind {
                        slot: $2,
                        elem: id0, map-[],
                    },
                ),
                [
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "e",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id0, map-[$f0 -> $f1],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id0, map-[$f0 -> $f1],
                "b": id0, map-[$f0 -> $f2],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id0, map-[$f0 -> $f1],
                "b": id0, map-[$f0 -> $f2],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = [
        {
            "a": id0, map-[$f0 -> $f5],
            "b": id0, map-[$f0 -> $f6],
        },
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id0, map-[$f0 -> $f1],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "c",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f1]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
                "b": id1, map-[$f1 -> $f3, $f2 -> $f4],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
                "b": id1, map-[$f1 -> $f3, $f2 -> $f4],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result out = [
        {
            "a": id1, map-[$f1 -> $f7, $f2 -> $f8],
            "b": id1, map-[$f1 -> $f7, $f2 -> $f8],
        },
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f3, $f2 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "c",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f3, $f2 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f3, $f2 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
                "b": id0, map-[$f0 -> $f3],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
                "b": id0, map-[$f0 -> $f3],
                "c": id0, map-[$f0 -> $f4],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "c",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
                "b": id0, map-[$f0 -> $f3],
                "c": id0, map-[$f0 -> $f4],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
                "b": id0, map-[$f0 -> $f3],
                "c": id0, map-[$f0 -> $f4],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f3, $f2 -> $f4],
                "b": id0, map-[$f0 -> $f3],
                "c": id0, map-[$f0 -> $f4],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "b",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result out = [
        {
            "a": id1, map-[$f1 -> $f9, $f2 -> $f10],
            "b": id0, map-[$f0 -> $f9],
            "c": id0, map-[$f0 -> $f10],
        },
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "b",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: None,
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f1]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f3 -> $f3, $f4 -> $f4]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f3, $1 -> $f4],
                src_id: id2,
            },
        },
        slots: {
            $f3,
            $f4,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f3 -> $f3, $f4 -> $f4],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f3, $f2 -> $f4],
            id1, map-[$f1 -> $f3, $f2 -> $f4],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        App(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Lam(
                    Bind {
                        slot: $1,
                        elem: id0, map-[],
                    },
                ),
                [
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "t",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Lam(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
        ),
        [
            ENode(
                App(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    ENode(
                        Var(
                            $1,
                        ),
                        [],
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            PVar(
                "b",
            ),
            PVar(
                "t",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            PVar(
                "e",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            ENode(
                App(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "e",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Let(
            Bind {
                slot: $1,
                elem: id0, map-[],
            },
            id0, map-[],
        ),
        [
            ENode(
                Lam(
                    Bind {
                        slot: $2,
                        elem: id0, map-[],
                    },
                ),
                [
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "e",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id0, map-[$f0 -> $f1],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id0, map-[$f0 -> $f1],
                "b": id0, map-[$f0 -> $f2],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id0, map-[$f0 -> $f1],
                "b": id0, map-[$f0 -> $f2],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id3, map-[$f11 -> $f13, $f12 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id3, map-[$f11 -> $f13, $f12 -> $f14],
                "b": id3, map-[$f11 -> $f14, $f12 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id3, map-[$f11 -> $f13, $f12 -> $f14],
                "b": id3, map-[$f11 -> $f14, $f12 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result out = [
        {
            "a": id0, map-[$f0 -> $f15],
            "b": id0, map-[$f0 -> $f16],
        },
        {
            "a": id3, map-[$f11 -> $f17, $f12 -> $f18],
            "b": id3, map-[$f11 -> $f18, $f12 -> $f17],
        },
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id0, map-[$f0 -> $f1],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id3, map-[$f11 -> $f13, $f12 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f14, $f12 -> $f13]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "c",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f1]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f13, $f12 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f12, $f2 -> $f11],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f12, $f2 -> $f11],
                "b": id0, map-[$f0 -> $f11],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f11, $f2 -> $f12],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f11, $f2 -> $f12],
                "b": id0, map-[$f0 -> $f11],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f12, $f2 -> $f11],
                "b": id0, map-[$f0 -> $f11],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f11, $f2 -> $f12],
                "b": id0, map-[$f0 -> $f11],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id1, map-[$f1 -> $f14, $f2 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id1, map-[$f1 -> $f14, $f2 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id1, map-[$f1 -> $f14, $f2 -> $f13],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id1, map-[$f1 -> $f14, $f2 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = [
        {
            "a": id1, map-[$f1 -> $f20, $f2 -> $f19],
            "b": id0, map-[$f0 -> $f19],
        },
        {
            "a": id1, map-[$f1 -> $f21, $f2 -> $f22],
            "b": id0, map-[$f0 -> $f21],
        },
        {
            "a": id1, map-[$f1 -> $f24, $f2 -> $f23],
            "b": id1, map-[$f1 -> $f24, $f2 -> $f23],
        },
        {
            "a": id1, map-[$f1 -> $f25, $f2 -> $f26],
            "b": id1, map-[$f1 -> $f26, $f2 -> $f25],
        },
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f12, $f2 -> $f11],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f11]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f11, $f2 -> $f12],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f11]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f14, $f2 -> $f13]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f14, $f2 -> $f13]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            PVar(
                "c",
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f12, $f2 -> $f11]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f11, $f2 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f14, $f2 -> $f13]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f13, $f2 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = []
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = []
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Mul(
            id0, map-[],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            ENode(
                Add(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "b",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f12, $f2 -> $f11],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f11]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f11, $f2 -> $f12],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f11]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f14, $f2 -> $f13]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f14],
                "c": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "c",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f14],
                "c": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f14],
                "c": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ]
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f14, $f2 -> $f13]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f14],
                "c": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "c",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f14],
                "c": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f14],
                "c": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f14],
                "c": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f14],
                "c": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "b",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "b",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] ematch_all result out = [
        {
            "a": id1, map-[$f1 -> $f28, $f2 -> $f27],
            "b": id0, map-[$f0 -> $f28],
            "c": id0, map-[$f0 -> $f27],
        },
        {
            "a": id1, map-[$f1 -> $f29, $f2 -> $f30],
            "b": id0, map-[$f0 -> $f30],
            "c": id0, map-[$f0 -> $f29],
        },
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "b",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "b",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] === Call EmatchAll ===
[slotted_egraphs::rewrite::ematch] pattern = ENode(
        Add(
            id0, map-[],
            id0, map-[],
        ),
        [
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "b",
                    ),
                ],
            ),
            ENode(
                Mul(
                    id0, map-[],
                    id0, map-[],
                ),
                [
                    PVar(
                        "a",
                    ),
                    PVar(
                        "c",
                    ),
                ],
            ),
        ],
    )
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ),
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2],
            },
            next: Some(
                Next {
                    stab: $f1,
                    ot: {
                        $f2: ProvenPerm {
                            elem: [$f1 -> $f2, $f2 -> $f1],
                        },
                        $f1: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f1 -> $f1, $f2 -> $f2],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id0, map-[$f0 -> $f1],
            id0, map-[$f0 -> $f2],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f1]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ),
            Add(
                id0, map-[$f0 -> $0],
                id0, map-[$f0 -> $1],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = []
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = []
[slotted_egraphs::rewrite::ematch] out = []
[slotted_egraphs::rewrite::ematch] outPatternChildren = []
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f11, $f12 -> $f12]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::egraph] enodes_applied i = id4, map-[$f13 -> $f13, $f14 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id1, map-[$f1 -> $0, $f2 -> $1],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id2,
            },
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f13, $1 -> $f14],
                src_id: id4,
            },
        },
        slots: {
            $f13,
            $f14,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f13 -> $f13, $f14 -> $f14],
            },
            next: Some(
                Next {
                    stab: $f13,
                    ot: {
                        $f14: ProvenPerm {
                            elem: [$f13 -> $f14, $f14 -> $f13],
                        },
                        $f13: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                    },
                    g: Group {
                        identity: ProvenPerm {
                            elem: [$f13 -> $f13, $f14 -> $f14],
                        },
                        next: None,
                    },
                },
            ),
        },
        syn_enode: Add(
            id3, map-[$f11 -> $f13, $f12 -> $f14],
            id3, map-[$f11 -> $f14, $f12 -> $f13],
        ),
        ..
    }
[slotted_egraphs::rewrite::ematch] continue because of discriminant mismatch
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f13, $f12 -> $f14]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "b",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f14, $f12 -> $f13]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "c",
        ),
    ]
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "c",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ]
[slotted_egraphs::egraph] enodes_applied i = id3, map-[$f11 -> $f14, $f12 -> $f13]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Mul(
                id1, map-[$f1 -> $0, $f2 -> $1],
                id0, map-[$f0 -> $0],
            ): ProvenSourceNode {
                elem: [$0 -> $f11, $1 -> $f12],
                src_id: id3,
            },
        },
        slots: {
            $f11,
            $f12,
        },
        usages: {
            Add(
                id3, map-[$f11 -> $0, $f12 -> $1],
                id3, map-[$f11 -> $1, $f12 -> $0],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f11 -> $f11, $f12 -> $f12],
            },
            next: None,
        },
        syn_enode: Mul(
            id1, map-[$f1 -> $f11, $f2 -> $f12],
            id0, map-[$f0 -> $f11],
        ),
        ..
    }
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "c",
        ),
    ]
[slotted_egraphs::lang] a = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] b = [
        AppliedId(
            id0, map-[],
        ),
        AppliedId(
            id0, map-[],
        ),
    ]
[slotted_egraphs::lang] return true 2
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "a",
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurse down2
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        PVar(
            "c",
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return next = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] recurseDownChildrenEclass return nextPatternChildren = [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] out = [
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f14, $f2 -> $f13],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
        State {
            partial_subst: {
                "a": id1, map-[$f1 -> $f13, $f2 -> $f14],
                "b": id0, map-[$f0 -> $f13],
                "c": id0, map-[$f0 -> $f14],
            },
            partial_slotmap: [],
        },
    ]
[slotted_egraphs::rewrite::ematch] outPatternChildren = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result out = [
        {
            "a": id1, map-[$f1 -> $f32, $f2 -> $f31],
            "b": id0, map-[$f0 -> $f31],
            "c": id0, map-[$f0 -> $f32],
        },
        {
            "a": id1, map-[$f1 -> $f34, $f2 -> $f33],
            "b": id0, map-[$f0 -> $f33],
            "c": id0, map-[$f0 -> $f34],
        },
        {
            "a": id1, map-[$f1 -> $f35, $f2 -> $f36],
            "b": id0, map-[$f0 -> $f35],
            "c": id0, map-[$f0 -> $f36],
        },
        {
            "a": id1, map-[$f1 -> $f37, $f2 -> $f38],
            "b": id0, map-[$f0 -> $f37],
            "c": id0, map-[$f0 -> $f38],
        },
    ]
[slotted_egraphs::rewrite::ematch] ematch_all result outPatterns = [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "b",
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        PVar(
                            "a",
                        ),
                        PVar(
                            "c",
                        ),
                    ],
                ),
            ],
        ),
    ]

thread 'arith::tst::t4' panicked at /home/pondnj/chc/project/slotted-egraphs/src/rewrite/ematch.rs:36:5:
assertion failed: out.len() == outPatterns.len()
stack backtrace:
   0: __rustc::rust_begin_unwind
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/panicking.rs:697:5
   1: core::panicking::panic_fmt
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/panicking.rs:75:14
   2: core::panicking::panic
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/panicking.rs:145:5
   3: slotted_egraphs::rewrite::ematch::ematch_all
             at ./src/rewrite/ematch.rs:36:5
   4: slotted_egraphs::rewrite::Rewrite<L,N>::new_if::{{closure}}
             at ./src/rewrite/mod.rs:79:42
   5: slotted_egraphs::rewrite::RewriteT<L,N,T>::into::{{closure}}
             at ./src/rewrite/mod.rs:35:51
   6: slotted_egraphs::rewrite::apply_rewrites::{{closure}}
             at ./src/rewrite/mod.rs:53:58
   7: core::iter::adapters::map::map_fold::{{closure}}
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:88:28
   8: <core::slice::iter::Iter<T> as core::iter::traits::iterator::Iterator>::fold
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:255:27
   9: <core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:128:19
  10: core::iter::traits::iterator::Iterator::for_each
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:827:14
  11: alloc::vec::Vec<T,A>::extend_trusted
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3611:26
  12: <alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs:29:14
  13: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter_nested.rs:62:16
  14: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:34:9
  15: <alloc::vec::Vec<T> as core::iter::traits::collect::FromIterator<T>>::from_iter
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3470:9
  16: core::iter::traits::iterator::Iterator::collect
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2027:9
  17: slotted_egraphs::rewrite::apply_rewrites
             at ./src/rewrite/mod.rs:53:78
  18: slotted_egraphs::run::runner::Runner<L,N,IterData,CustomErrorT>::run_one
             at ./src/run/runner.rs:181:24
  19: slotted_egraphs::run::runner::Runner<L,N,IterData,CustomErrorT>::run
             at ./src/run/runner.rs:153:29
  20: entry::assert_reaches
             at ./tests/entry.rs:122:25
  21: entry::arith::tst::t4::{{closure}}
             at ./tests/arith/tst.rs:56:5
  22: core::ops::function::FnOnce::call_once
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
  23: serial_test::serial_code_lock::local_serial_core
             at /home/pondnj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serial_test-1.0.0/src/serial_code_lock.rs:25:5
  24: entry::arith::tst::t4
             at ./tests/arith/tst.rs:46:1
  25: entry::arith::tst::t4::{{closure}}
             at ./tests/arith/tst.rs:47:8
  26: core::ops::function::FnOnce::call_once
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
  27: core::ops::function::FnOnce::call_once
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
test arith::tst::t4 ... FAILED

failures:

failures:
    arith::tst::t4

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 70 filtered out; finished in 0.09s

error: test failed, to rerun pass `--test entry`

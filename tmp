warning: unreachable expression
  --> src/lang.rs:77:17
   |
73 | /                 panic!(
74 | |                     "(Pond) slotted_egraphs::lang::AppliedId::from_syntax: expected a single applied id, got {:?}",
75 | |                     elems
76 | |                 );
   | |_________________- any code following this expression is unreachable
77 |                   None
   |                   ^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` on by default

warning: unreachable expression
   --> src/lang.rs:122:17
    |
118 | /                 panic!(
119 | |                     "(Pond) slotted_egraphs::slot::Slot::from_syntax: expected a single slot, got {:?}",
120 | |                     elems
121 | |                 );
    | |_________________- any code following this expression is unreachable
122 |                   None
    |                   ^^^^ unreachable expression

warning: unreachable expression
   --> src/lang.rs:155:25
    |
155 |                           None
    |                           ^^^^ unreachable expression
...
166 | / bare_language_child!(
167 | |     u128, u64, u32, u16, u8, i128, i64, i32, i16, i8, usize, isize, bool, char, Symbol
168 | | );
    | | -
    | | |
    | |_any code following this expression is unreachable
    |   in this macro invocation
    |
    = note: this warning originates in the macro `bare_language_child` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unreachable statement
   --> src/lang.rs:221:13
    |
217 | /             panic!(
218 | |                 "(Pond) slotted_egraphs::lang::Bind::from_syntax: expected a single slot, got {:?}",
219 | |                 elems
220 | |             );
    | |_____________- any code following this expression is unreachable
221 |               return None;
    |               ^^^^^^^^^^^^ unreachable statement

warning: unused variable: `v`
  --> src/debug.rs:67:41
   |
67 |                         SyntaxElem::Vec(v) => {
   |                                         ^ help: if this is intentional, prefix it with an underscore: `_v`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: `slotted-egraphs` (lib) generated 19 warnings (14 duplicates)
   Compiling slotted-egraphs v0.0.36 (/home/pondnj/chc/project/slotted-egraphs)
warning: `slotted-egraphs` (lib test) generated 19 warnings (19 duplicates)
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Let(a0, a1))
}, "add" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Add(a0, a1))
}, "mul" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Mul(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: Let(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Rise :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Rise :: Let(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Var :: F(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: F(a0, a1))
}, "g" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: G(a0, a1))
}, "h" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: H(a0, a1))
}
from_syntax_arms1 = "lambda" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Lam(a0))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Var(a0))
}, "sing" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sing(a0, a1))
}, "sum" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind < Bind <
        AppliedId > > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sum(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Lam(a0, a1))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(ArrayLang :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Let(a0, a1))
}
from_syntax_arms1 = "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Var(a0))
}, "and" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(CHC :: And(a0))
}
warning: ambiguous glob re-exports
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^ the name `get_all_rewrites` in the value namespace is first re-exported here
...
26 | pub use chc::*;
   |         ------ but the name `get_all_rewrites` in the value namespace is also re-exported here
   |
   = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:12:27
   |
12 |     assert_reaches(a, b, &get_all_rewrites()[..], 3);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
   = note: `#[warn(ambiguous_glob_imports)]` on by default

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:25:27
   |
25 |     assert_reaches(a, b, &get_all_rewrites()[..], 2);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:38:27
   |
38 |     assert_reaches(a, b, &get_all_rewrites()[..], 3);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:50:27
   |
50 |     assert_reaches(a, b, &get_all_rewrites()[..], 10);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:73:27
   |
73 |     assert_reaches(a, b, &get_all_rewrites()[..], 10);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `slotted-egraphs` (test "entry") generated 6 warnings
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-3e46d232c8c3c10a)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-e549fe6ff08365f6)

running 1 test

s = "(and <?1 (and <?2 ?3>)>)"
tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("1"), LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("1")
parse_pattern pat_struct = PVar(
    "1",
), pat_display = ?1
parse_nested_syntax_elem ret = Ok((Pattern(PVar("1")), [LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("2"), PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("2")
parse_pattern pat_struct = PVar(
    "2",
), pat_display = ?2
parse_nested_syntax_elem ret = Ok((Pattern(PVar("2")), [PVar("3"), RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("3"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("3")
parse_pattern pat_struct = PVar(
    "3",
), pat_display = ?3
parse_nested_syntax_elem ret = Ok((Pattern(PVar("3")), [RVecBracket, RParen, RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(PVar("2")), Pattern(PVar("3"))])]
transformed syntax_elems = [PVar("2"), PVar("3")]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        PVar(
            "2",
        ),
        PVar(
            "3",
        ),
    ],
), pat_display = (and ?2 ?3)
parse_nested_syntax_elem ret = Ok((Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")])), [RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(PVar("1")), Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")]))])]
transformed syntax_elems = [PVar("1"), ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")])]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), ENode(And([id0, map-[], id0, map-[]]), [PVar("2"), PVar("3")])])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        PVar(
            "1",
        ),
        ENode(
            And(
                [
                    id0, map-[],
                    id0, map-[],
                ],
            ),
            [
                PVar(
                    "2",
                ),
                PVar(
                    "3",
                ),
            ],
        ),
    ],
), pat_display = (and ?1 (and ?2 ?3))

s = "(and <(and <?1 ?2>) ?3>)"
tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern input tok = [PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("1"), PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("1")
parse_pattern pat_struct = PVar(
    "1",
), pat_display = ?1
parse_nested_syntax_elem ret = Ok((Pattern(PVar("1")), [PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern input tok = [PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("2"), RVecBracket, RParen, PVar("3"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("2")
parse_pattern pat_struct = PVar(
    "2",
), pat_display = ?2
parse_nested_syntax_elem ret = Ok((Pattern(PVar("2")), [RVecBracket, RParen, PVar("3"), RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(PVar("1")), Pattern(PVar("2"))])]
transformed syntax_elems = [PVar("1"), PVar("2")]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        PVar(
            "1",
        ),
        PVar(
            "2",
        ),
    ],
), pat_display = (and ?1 ?2)
parse_nested_syntax_elem ret = Ok((Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")])), [PVar("3"), RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [PVar("3"), RVecBracket, RParen]
parse_pattern input tok = [PVar("3"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("3"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("3")
parse_pattern pat_struct = PVar(
    "3",
), pat_display = ?3
parse_nested_syntax_elem ret = Ok((Pattern(PVar("3")), [RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")])), Pattern(PVar("3"))])]
transformed syntax_elems = [ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")]), PVar("3")]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [ENode(And([id0, map-[], id0, map-[]]), [PVar("1"), PVar("2")]), PVar("3")])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        ENode(
            And(
                [
                    id0, map-[],
                    id0, map-[],
                ],
            ),
            [
                PVar(
                    "1",
                ),
                PVar(
                    "2",
                ),
            ],
        ),
        PVar(
            "3",
        ),
    ],
), pat_display = (and (and ?1 ?2) ?3)

s = "(and <?a ?b>)"
tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), PVar("b"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RVecBracket, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret = Ok((Pattern(PVar("a")), [PVar("b"), RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RVecBracket, RParen]
parse_pattern input tok = [PVar("b"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret = Ok((Pattern(PVar("b")), [RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(PVar("a")), Pattern(PVar("b"))])]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (and ?a ?b)

s = "(and <?b ?a>)"
tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("a"), RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("a"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("a"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, PVar("b"), PVar("a"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RVecBracket, RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret = Ok((Pattern(PVar("b")), [PVar("a"), RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RVecBracket, RParen]
parse_pattern input tok = [PVar("a"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("a"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret = Ok((Pattern(PVar("a")), [RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(PVar("b")), Pattern(PVar("a"))])]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (and ?b ?a)

s = "(and <?a (and <?b ?c>)>)"
tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret = Ok((Pattern(PVar("a")), [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret = Ok((Pattern(PVar("b")), [PVar("c"), RVecBracket, RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern input tok = [PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RVecBracket, RParen, RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret = Ok((Pattern(PVar("c")), [RVecBracket, RParen, RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(PVar("b")), Pattern(PVar("c"))])]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (and ?b ?c)
parse_nested_syntax_elem ret = Ok((Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")])), [RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(PVar("a")), Pattern(ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")]))])]
transformed syntax_elems = [PVar("a"), ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [PVar("a"), ENode(And([id0, map-[], id0, map-[]]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            And(
                [
                    id0, map-[],
                    id0, map-[],
                ],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (and ?a (and ?b ?c))

s = "(and <?a ?b ?c>)"
tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), PVar("c"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret = Ok((Pattern(PVar("a")), [PVar("b"), PVar("c"), RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RVecBracket, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret = Ok((Pattern(PVar("b")), [PVar("c"), RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RVecBracket, RParen]
parse_pattern input tok = [PVar("c"), RVecBracket, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RVecBracket, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret = Ok((Pattern(PVar("c")), [RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(PVar("a")), Pattern(PVar("b")), Pattern(PVar("c"))])]
transformed syntax_elems = [PVar("a"), PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[], id0, map-[]]), [PVar("a"), PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (and ?a ?b ?c)

s = "(and <(and <(var $0) (var $1)>) (var $2)>)"
tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret = Ok((Pattern(ENode(Var($1), [])), [RVecBracket, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))])]
transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        ENode(
            Var(
                $0,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (and (var $0) (var $1))
parse_nested_syntax_elem ret = Ok((Pattern(ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($2)
syntax_elems_mock = [String("var"), Slot($2)]
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Some(Var($2))
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Var($2)
before syntax_elems = [String("var"), Slot($2)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($2), [])
parse_pattern pat_struct = ENode(
    Var(
        $2,
    ),
    [],
), pat_display = (var $2)
parse_nested_syntax_elem ret = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])])), Pattern(ENode(Var($2), []))])]
transformed syntax_elems = [ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[]]), [ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        ENode(
            And(
                [
                    id0, map-[],
                    id0, map-[],
                ],
            ),
            [
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Var(
                $2,
            ),
            [],
        ),
    ],
), pat_display = (and (and (var $0) (var $1)) (var $2))
pattern_to_re input pat = ENode(And([id0, map-[], id0, map-[]]), [ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])
pattern_to_re input pat = ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Var($0), [])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Var($2), [])
RecExpr::parse: ret = ENode(And([id0, map-[], id0, map-[]]), [ENode(And([id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])

s = "(and <(var $0) (var $1) (var $2)>)"
tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($2)
syntax_elems_mock = [String("var"), Slot($2)]
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Some(Var($2))
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Var($2)
before syntax_elems = [String("var"), Slot($2)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($2), [])
parse_pattern pat_struct = ENode(
    Var(
        $2,
    ),
    [],
), pat_display = (var $2)
parse_nested_syntax_elem ret = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, RParen]))
syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
node = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
tmp = Some([id0, map-[], id0, map-[], id0, map-[]])
fields: [id0, map-[], id0, map-[], id0, map-[]]
from_syntax::ret = Some(And([id0, map-[], id0, map-[], id0, map-[]]))
node = And([id0, map-[], id0, map-[], id0, map-[]])
before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))])]
transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), [])]
parse_pattern_nosubst ret2 = ENode(And([id0, map-[], id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), [])])
parse_pattern pat_struct = ENode(
    And(
        [
            id0, map-[],
            id0, map-[],
            id0, map-[],
        ],
    ),
    [
        ENode(
            Var(
                $0,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        ENode(
            Var(
                $2,
            ),
            [],
        ),
    ],
), pat_display = (and (var $0) (var $1) (var $2))
pattern_to_re input pat = ENode(And([id0, map-[], id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), [])])
pattern_to_re input pat = ENode(Var($0), [])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Var($2), [])
RecExpr::parse: ret = ENode(And([id0, map-[], id0, map-[], id0, map-[]]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), [])])
[tests/entry.rs:124:5] &report.stop_reason = Other(
    Reached,
)


id0($f0):
>> Var($f0)
 - Var($f0)

id1($f1, $f2):
>> And([id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2]])
 - And([id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2]])
 -- [$f1 -> $f2, $f2 -> $f1]

id3($f11, $f12, $f13):
>> And([id0, map-[$f0 -> $f13], id1, map-[$f1 -> $f12, $f2 -> $f11]])
 - And([id1, map-[$f1 -> $f11, $f2 -> $f12], id0, map-[$f0 -> $f13]])
 - And([id0, map-[$f0 -> $f13], id1, map-[$f1 -> $f11, $f2 -> $f12]])
 - And([id0, map-[$f0 -> $f13], id0, map-[$f0 -> $f12], id0, map-[$f0 -> $f11]])
 -- [$f11 -> $f13, $f12 -> $f11, $f13 -> $f12]
 -- [$f11 -> $f11, $f12 -> $f13, $f13 -> $f12]
 -- [$f11 -> $f12, $f12 -> $f11, $f13 -> $f13]

test chc::and ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 70 filtered out; finished in 0.00s


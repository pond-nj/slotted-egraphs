   Compiling slotted-egraphs v0.0.36 (/Users/nutdranaijaruthikorn/Downloads/2025/PhD/Project/slotted-egraphs)
warning: unreachable expression
  --> src/lang.rs:93:17
   |
89 | /                 panic!(
90 | |                     "(Pond) slotted_egraphs::lang::AppliedId::from_syntax: expected a single applied id, got {:?}",
91 | |                     elems
92 | |                 );
   | |_________________- any code following this expression is unreachable
93 |                   None
   |                   ^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` on by default

warning: unreachable expression
   --> src/lang.rs:141:17
    |
137 | /                 panic!(
138 | |                     "(Pond) slotted_egraphs::slot::Slot::from_syntax: expected a single slot, got {:?}",
139 | |                     elems
140 | |                 );
    | |_________________- any code following this expression is unreachable
141 |                   None
    |                   ^^^^ unreachable expression

warning: unreachable expression
   --> src/lang.rs:178:25
    |
178 |                           None
    |                           ^^^^ unreachable expression
...
192 | / bare_language_child!(
193 | |     u128, u64, u32, u16, u8, i128, i64, i32, i16, i8, usize, isize, bool, char, Symbol, String
194 | | );
    | | -
    | | |
    | |_any code following this expression is unreachable
    |   in this macro invocation
    |
    = note: this warning originates in the macro `bare_language_child` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unreachable expression
   --> src/lang.rs:262:17
    |
261 |                 panic!("(Pond) slotted_egraphs::lang::AppliedIdOrStar::from_syntax");
    |                 -------------------------------------------------------------------- any code following this expression is unreachable
262 |                 None
    |                 ^^^^ unreachable expression

warning: unreachable statement
   --> src/lang.rs:327:13
    |
323 | /             panic!(
324 | |                 "(Pond) slotted_egraphs::lang::Bind::from_syntax: expected a single slot, got {:?}",
325 | |                 elems
326 | |             );
    | |_____________- any code following this expression is unreachable
327 |               return None;
    |               ^^^^^^^^^^^^ unreachable statement

warning: unused variable: `v`
  --> src/debug.rs:67:41
   |
67 |                         SyntaxElem::Vec(v) => {
   |                                         ^ help: if this is intentional, prefix it with an underscore: `_v`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: `slotted-egraphs` (lib) generated 21 warnings (15 duplicates)
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "add" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "mul" } }), None, None]
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Let(a0, a1))
}, "add" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Add(a0, a1))
}, "mul" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Mul(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "add" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "mul" } }), return None
v: Variant { attrs: [], ident: Ident { ident: "Number", span: #0 bytes(3934..3940) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "u32", span: #0 bytes(3941..3944) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
v: Variant { attrs: [], ident: Ident { ident: "Symbol", span: #0 bytes(3955..3961) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "Symbol", span: #0 bytes(3962..3968) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
from_syntax_arms2 = if let Some(a) = < u32 > :: from_syntax(elems)
{ return Some(Arith :: Number(a)); }, if let Some(a) = < Symbol > ::
from_syntax(elems) { return Some(Arith :: Symbol(a)); }
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Arith
{
    Lam(Bind < AppliedId >), App(AppliedId, AppliedId), Var(Slot),
    Let(Bind < AppliedId > , AppliedId), Add(AppliedId, AppliedId),
    Mul(AppliedId, AppliedId), Number(u32), Symbol(Symbol),
} impl Language for Arith
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lam"))];
                out.extend(a0.to_syntax()); out
            }, Arith :: App(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("app"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Arith :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, Arith :: Let(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("let"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Arith :: Add(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("add"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Arith :: Mul(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("mul"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Arith :: Number(a0) => { a0.to_syntax() }, Arith :: Symbol(a0)
            => { a0.to_syntax() }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lam" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Arith :: Lam(a0))
            }, "app" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Arith :: App(a0, a1))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Arith :: Var(a0))
            }, "let" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Arith :: Let(a0, a1))
            }, "add" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Arith :: Add(a0, a1))
            }, "mul" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Arith :: Mul(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); if let Some(a) = < u32 >
                :: from_syntax(elems) { return Some(Arith :: Number(a)); } if
                let Some(a) = < Symbol > :: from_syntax(elems)
                { return Some(Arith :: Symbol(a)); } debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Arith :: Lam(a0) => { a0.weak_shape_impl(m); }, Arith ::
            App(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Arith :: Var(a0) => { a0.weak_shape_impl(m); }, Arith ::
            Let(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Arith :: Add(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Arith ::
            Mul(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Arith :: Number(a0) => { a0.weak_shape_impl(m); }, Arith ::
            Symbol(a0) => { a0.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } })]
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: Let(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Lambda
{
    Lam(Bind < AppliedId >), App(AppliedId, AppliedId), Var(Slot),
    Let(Bind < AppliedId > , AppliedId),
} impl Language for Lambda
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lam"))];
                out.extend(a0.to_syntax()); out
            }, Lambda :: App(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("app"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Lambda :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, Lambda :: Let(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("let"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lam" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Lambda :: Lam(a0))
            }, "app" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Lambda :: App(a0, a1))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Lambda :: Var(a0))
            }, "let" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Lambda :: Let(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Lambda :: Lam(a0) => { a0.weak_shape_impl(m); }, Lambda ::
            App(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Lambda :: Var(a0) => { a0.weak_shape_impl(m); }, Lambda ::
            Let(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), None, None]
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Rise :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Rise :: Let(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), return None
v: Variant { attrs: [], ident: Ident { ident: "Number", span: #0 bytes(42642..42648) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "u32", span: #0 bytes(42649..42652) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
v: Variant { attrs: [], ident: Ident { ident: "Symbol", span: #0 bytes(42663..42669) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "Symbol", span: #0 bytes(42670..42676) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
from_syntax_arms2 = if let Some(a) = < u32 > :: from_syntax(elems)
{ return Some(Rise :: Number(a)); }, if let Some(a) = < Symbol > ::
from_syntax(elems) { return Some(Rise :: Symbol(a)); }
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Rise
{
    Lam(Bind < AppliedId >), App(AppliedId, AppliedId), Var(Slot),
    Let(Bind < AppliedId > , AppliedId), Number(u32), Symbol(Symbol),
} impl Language for Rise
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lam"))];
                out.extend(a0.to_syntax()); out
            }, Rise :: App(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("app"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Rise :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, Rise :: Let(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("let"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Rise :: Number(a0) => { a0.to_syntax() }, Rise :: Symbol(a0) =>
            { a0.to_syntax() }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lam" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Rise :: Lam(a0))
            }, "app" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Rise :: App(a0, a1))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Rise :: Var(a0))
            }, "let" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Rise :: Let(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); if let Some(a) = < u32 >
                :: from_syntax(elems) { return Some(Rise :: Number(a)); } if
                let Some(a) = < Symbol > :: from_syntax(elems)
                { return Some(Rise :: Symbol(a)); } debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Rise :: Lam(a0) => { a0.weak_shape_impl(m); }, Rise :: App(a0, a1)
            => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Rise ::
            Var(a0) => { a0.weak_shape_impl(m); }, Rise :: Let(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Rise ::
            Number(a0) => { a0.weak_shape_impl(m); }, Rise :: Symbol(a0) =>
            { a0.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "f" } })]
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Var :: F(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "f" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Var
{ F(Slot, Slot), } impl Language for Var
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("f"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "f" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; Some(Var :: F(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Var :: F(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "f" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "g" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "h" } })]
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: F(a0, a1))
}, "g" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: G(a0, a1))
}, "h" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: H(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "f" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "g" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "h" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Fgh
{ F(Slot, Slot), G(Slot, Slot), H(Slot, Slot), } impl Language for Fgh
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("f"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Fgh :: G(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("g"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Fgh :: H(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("h"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "f" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; Some(Fgh :: F(a0, a1))
            }, "g" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; Some(Fgh :: G(a0, a1))
            }, "h" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; Some(Fgh :: H(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Fgh :: F(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Fgh ::
            G(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Fgh :: H(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lambda" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "sing" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "sum" } })]
from_syntax_arms1 = "lambda" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Lam(a0))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Var(a0))
}, "sing" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sing(a0, a1))
}, "sum" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind < Bind <
        AppliedId > > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sum(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lambda" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "sing" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "sum" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Sdql
{
    Lam(Bind < AppliedId >), Var(Slot), Sing(AppliedId, AppliedId),
    Sum(AppliedId, Bind < Bind < AppliedId > >),
} impl Language for Sdql
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lambda"))];
                out.extend(a0.to_syntax()); out
            }, Sdql :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, Sdql :: Sing(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("sing"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Sdql :: Sum(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("sum"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lambda" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Sdql :: Lam(a0))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Sdql :: Var(a0))
            }, "sing" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Sdql :: Sing(a0, a1))
            }, "sum" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < Bind < AppliedId > > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Sdql :: Sum(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Sdql :: Lam(a0) => { a0.weak_shape_impl(m); }, Sdql :: Var(a0) =>
            { a0.weak_shape_impl(m); }, Sdql :: Sing(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Sdql ::
            Sum(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), None, None]
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Lam(a0, a1))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(ArrayLang :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Let(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), return None
v: Variant { attrs: [], ident: Ident { ident: "Number", span: #0 bytes(62930..62936) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "u32", span: #0 bytes(62937..62940) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
v: Variant { attrs: [], ident: Ident { ident: "Symbol", span: #0 bytes(62951..62957) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "Symbol", span: #0 bytes(62958..62964) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
from_syntax_arms2 = if let Some(a) = < u32 > :: from_syntax(elems)
{ return Some(ArrayLang :: Number(a)); }, if let Some(a) = < Symbol > ::
from_syntax(elems) { return Some(ArrayLang :: Symbol(a)); }
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum
ArrayLang
{
    Lam(Slot, AppliedId), App(AppliedId, AppliedId), Var(Slot),
    Let(Bind < AppliedId > , AppliedId), Number(u32), Symbol(Symbol),
} impl Language for ArrayLang
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lam"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, ArrayLang :: App(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("app"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, ArrayLang :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, ArrayLang :: Let(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("let"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, ArrayLang :: Number(a0) => { a0.to_syntax() }, ArrayLang ::
            Symbol(a0) => { a0.to_syntax() }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lam" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(ArrayLang :: Lam(a0, a1))
            }, "app" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(ArrayLang :: App(a0, a1))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest;
                Some(ArrayLang :: Var(a0))
            }, "let" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(ArrayLang :: Let(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); if let Some(a) = < u32 >
                :: from_syntax(elems) { return Some(ArrayLang :: Number(a)); }
                if let Some(a) = < Symbol > :: from_syntax(elems)
                { return Some(ArrayLang :: Symbol(a)); } debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            ArrayLang :: Lam(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, ArrayLang ::
            App(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            ArrayLang :: Var(a0) => { a0.weak_shape_impl(m); }, ArrayLang ::
            Let(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            ArrayLang :: Number(a0) => { a0.weak_shape_impl(m); }, ArrayLang
            :: Symbol(a0) => { a0.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "and" } })]
from_syntax_arms1 = "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(And :: Var(a0))
}, "and" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec <
        AppliedIdOrStar > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(And :: And(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "and" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum And
{ Var(Slot), And(Vec < AppliedIdOrStar > , AppliedId), } impl Language for And
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
warning: `slotted-egraphs` (lib test) generated 21 warnings (21 duplicates)
                out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, And :: And(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("and"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(And :: Var(a0))
            }, "and" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Vec <
                    AppliedIdOrStar > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(And :: And(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            And :: Var(a0) => { a0.weak_shape_impl(m); }, And :: And(a0, a1)
            => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "pred" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "new" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "compose" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "true" } }), None]
from_syntax_arms1 = "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Var(a0))
}, "pred" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < Slot > >
        :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(CHC :: PredSyntax(a0, a1))
}, "new" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a2 = tmp ? ; debug!
    ("fields: {:?}", a2); children = rest; Some(CHC :: New(a0, a1, a2))
}, "compose" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Compose(a0))
}, "true" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; Some(CHC :: True())
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "pred" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "new" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "compose" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "true" } }), return None
v: Variant { attrs: [], ident: Ident { ident: "PredName", span: #0 bytes(66170..66178) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "String", span: #0 bytes(66179..66185) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
from_syntax_arms2 = if let Some(a) = < String > :: from_syntax(elems)
{ return Some(CHC :: PredName(a)); }
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum CHC
{
    Var(Slot), PredSyntax(AppliedId, Vec < Slot >),
    New(AppliedId, AppliedId, Vec < AppliedId >), Compose(Vec < AppliedId >),
    True(), PredName(String),
} impl Language for CHC
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); let out =
                out.chain(a2.all_slot_occurrences_iter_mut()); out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut()); let out =
                out.chain(a2.public_slot_occurrences_iter_mut());
                out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); let out =
                out.chain(a2.applied_id_occurrences_iter_mut()); out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied()); let out =
                out.chain(a2.all_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied()); let
                out = out.chain(a2.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); let out =
                out.chain(a2.applied_id_occurrences_iter()); out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("pred"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, CHC :: New(a0, a1, a2) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("new"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax());
                out.extend(a2.to_syntax()); out
            }, CHC :: Compose(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("compose"))];
                out.extend(a0.to_syntax()); out
            }, CHC :: True() =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("true"))]; out
            }, CHC :: PredName(a0) => { a0.to_syntax() }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(CHC :: Var(a0))
            }, "pred" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Vec <
                    Slot > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(CHC :: PredSyntax(a0, a1))
            }, "new" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Vec <
                    AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a2 = tmp ? ; debug!
                ("fields: {:?}", a2); children = rest;
                Some(CHC :: New(a0, a1, a2))
            }, "compose" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Vec <
                    AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest;
                Some(CHC :: Compose(a0))
            }, "true" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children;
                Some(CHC :: True())
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); if let Some(a) = <
                String > :: from_syntax(elems)
                { return Some(CHC :: PredName(a)); } debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied()); let
                out = out.chain(a2.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            CHC :: Var(a0) => { a0.weak_shape_impl(m); }, CHC ::
            PredSyntax(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, CHC ::
            New(a0, a1, a2) =>
            {
                a0.weak_shape_impl(m); a1.weak_shape_impl(m);
                a2.weak_shape_impl(m);
            }, CHC :: Compose(a0) => { a0.weak_shape_impl(m); }, CHC :: True()
            => {}, CHC :: PredName(a0) => { a0.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); let out =
                out.chain(a1.get_type().into_iter()); let out =
                out.chain(a2.get_type().into_iter()); out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.get_type().into_iter()); out.collect()
            }
        }
    }
}
    Finished `test` profile [unoptimized + debuginfo] target(s) in 3.48s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-f4bcfb6e9993f349)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-b7cdb244417a21af)

running 1 test
[slotted_egraphs::parse] 
    s = "(and <*> ?b)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Star])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([Star]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([Star]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([Star]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([Star])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [Star]
[entry::chc] tmp = Some([Star])
[entry::chc] fields: [Star]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([Star], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([Star], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([Star]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([Star]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([Star])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [Star]
[entry::chc] tmp = Some([Star])
[entry::chc] fields: [Star]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([Star], id0, map-[]))
[slotted_egraphs::parse] node = And([Star], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Star]), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [Star, PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([Star], id0, map-[]), [Star, PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                Star,
            ],
            id0, map-[],
        ),
        [
            Star,
            PVar(
                "b",
            ),
        ],
    ), pat_display = (and * *)
[slotted_egraphs::parse] 
    s = "(and <?a> ?b)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RVecBracket, PVar("b"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("a"))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("a"))]), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[])], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (and ?a ?b)
[slotted_egraphs::parse] 
    s = "(and <(and <(var $0) (var $1)> (var $3)) (var $2)> (var $3))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($0)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($0)]
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node1 = Some(Var($0))
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node = Var($0)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($0)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($0), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $0,
        ),
        [],
    ), pat_display = (var $0)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($3)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($3)]
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node1 = Some(Var($3))
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node = Var($3)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($3)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($3), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $3,
        ),
        [],
    ), pat_display = (var $3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]), Pattern(ENode(Var($3), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $0,
                ),
                [],
            ),
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            ENode(
                Var(
                    $3,
                ),
                [],
            ),
        ],
    ), pat_display = (and (var $0) (var $1) (var $3))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($2)]
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node1 = Some(Var($2))
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node = Var($2)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($2)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($2), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $2,
        ),
        [],
    ), pat_display = (var $2)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])), Pattern(ENode(Var($2), []))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($3)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($3)]
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node1 = Some(Var($3))
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node = Var($3)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($3)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($3), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $3,
        ),
        [],
    ), pat_display = (var $3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])), Pattern(ENode(Var($2), []))]), Pattern(ENode(Var($3), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            ENode(
                And(
                    [
                        AppliedId(
                            id0, map-[],
                        ),
                        AppliedId(
                            id0, map-[],
                        ),
                    ],
                    id0, map-[],
                ),
                [
                    ENode(
                        Var(
                            $0,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $1,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $3,
                        ),
                        [],
                    ),
                ],
            ),
            ENode(
                Var(
                    $2,
                ),
                [],
            ),
            ENode(
                Var(
                    $3,
                ),
                [],
            ),
        ],
    ), pat_display = (and (and (var $0) (var $1) (var $3)) (var $2) (var $3))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($0), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($1), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($3), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($2), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($3), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::parse] 
    s = "(and <(var $0) (var $1) (var $2)> (var $3))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($0)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($0)]
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node1 = Some(Var($0))
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node = Var($0)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($0)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($0), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $0,
        ),
        [],
    ), pat_display = (var $0)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($2)]
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node1 = Some(Var($2))
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node = Var($2)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($2)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($2), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $2,
        ),
        [],
    ), pat_display = (var $2)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($3)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($3)]
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node1 = Some(Var($3))
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node = Var($3)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($3)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($3), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $3,
        ),
        [],
    ), pat_display = (var $3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))]), Pattern(ENode(Var($3), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $0,
                ),
                [],
            ),
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            ENode(
                Var(
                    $2,
                ),
                [],
            ),
            ENode(
                Var(
                    $3,
                ),
                [],
            ),
        ],
    ), pat_display = (and (var $0) (var $1) (var $2) (var $3))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($0), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($1), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($2), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($3), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])])
ematch_all pattern = ENode(And([Star], id0, map-[]), [Star, PVar("b")])
ematch_impl pattern = ENode(And([Star], id0, map-[]), [Star, PVar("b")])
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            And(
                [
                    AppliedId(
                        id0, map-[$f0 -> $0],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $1],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ),
            And(
                [
                    AppliedId(
                        id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $3],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
enodes_applied result = [Var($f0)]
ematch_impl enodes in eclass = [Var($f0)]
ematch_impl continue at Discriminant(1) != Discriminant(0)
ematch_impl pattern = ENode(And([Star], id0, map-[]), [Star, PVar("b")])
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2, $f3 -> $f3]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            And(
                [
                    AppliedId(
                        id0, map-[$f0 -> $0],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $1],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2, $2 -> $f3],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
            $f3,
        },
        usages: {
            And(
                [
                    AppliedId(
                        id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $3],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2, $f3 -> $f3],
            },
            next: None,
        },
        syn_enode: And(
            [
                AppliedId(
                    id0, map-[$f0 -> $f1],
                ),
                AppliedId(
                    id0, map-[$f0 -> $f2],
                ),
            ],
            id0, map-[$f0 -> $f3],
        ),
        ..
    }
enodes_applied result = [And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])]
ematch_impl enodes in eclass = [And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])]
clear_n2: And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
n_sh: And([Star], id0, map-[])
clear_n2_sh: And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
ematch_impl children_type [Star, AppliedId(id0, map-[])] vs [AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
eq with star = true
ematch_impl continue at And([Star], id0, map-[]) != And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
ematch_impl pattern = ENode(And([Star], id0, map-[]), [Star, PVar("b")])
[slotted_egraphs::egraph] enodes_applied i = id2, map-[$f4 -> $f4, $f5 -> $f5, $f6 -> $f6, $f7 -> $f7]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            And(
                [
                    AppliedId(
                        id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $3],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ): ProvenSourceNode {
                elem: [$0 -> $f4, $1 -> $f5, $2 -> $f7, $3 -> $f6],
                src_id: id2,
            },
        },
        slots: {
            $f4,
            $f5,
            $f6,
            $f7,
        },
        usages: {},
        group: Group {
            identity: ProvenPerm {
                elem: [$f4 -> $f4, $f5 -> $f5, $f6 -> $f6, $f7 -> $f7],
            },
            next: None,
        },
        syn_enode: And(
            [
                AppliedId(
                    id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7],
                ),
                AppliedId(
                    id0, map-[$f0 -> $f6],
                ),
            ],
            id0, map-[$f0 -> $f7],
        ),
        ..
    }
enodes_applied result = [And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7])]
ematch_impl enodes in eclass = [And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7])]
clear_n2: And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
n_sh: And([Star], id0, map-[])
clear_n2_sh: And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
ematch_impl children_type [Star, AppliedId(id0, map-[])] vs [AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
eq with star = true
ematch_impl continue at And([Star], id0, map-[]) != And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
ematch_all out = []
[tests/entry.rs:124:5] &report.stop_reason = Saturated


id0($f0):
>> Var($f0)
 - Var($f0)

id1($f1, $f2, $f3):
>> And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])
 - And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])

id2($f4, $f5, $f6, $f7):
>> And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7])
 - And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7])

thread 'chc::and' panicked at tests/entry.rs:136:5:
failed to reach goal
stack backtrace:
   0: _rust_begin_unwind
   1: core::panicking::panic_fmt
   2: entry::assert_reaches
             at ./tests/entry.rs:136:5
   3: entry::chc::and
             at ./tests/chc/mod.rs:67:5
   4: entry::chc::and::{{closure}}
             at ./tests/chc/mod.rs:52:9
   5: core::ops::function::FnOnce::call_once
             at /private/tmp/rust-20241019-8391-fxpxmx/rustc-1.82.0-src/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
test chc::and ... FAILED

failures:

failures:
    chc::and

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 70 filtered out; finished in 0.05s

error: test failed, to rerun pass `--test entry`

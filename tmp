warning: unreachable expression
  --> src/lang.rs:77:17
   |
73 | /                 panic!(
74 | |                     "(Pond) slotted_egraphs::lang::AppliedId::from_syntax: expected a single applied id, got {:?}",
75 | |                     elems
76 | |                 );
   | |_________________- any code following this expression is unreachable
77 |                   None
   |                   ^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` on by default

warning: unreachable expression
   --> src/lang.rs:122:17
    |
118 | /                 panic!(
119 | |                     "(Pond) slotted_egraphs::slot::Slot::from_syntax: expected a single slot, got {:?}",
120 | |                     elems
121 | |                 );
    | |_________________- any code following this expression is unreachable
122 |                   None
    |                   ^^^^ unreachable expression

warning: unreachable expression
   --> src/lang.rs:155:25
    |
155 |                           None
    |                           ^^^^ unreachable expression
...
166 | / bare_language_child!(
167 | |     u128, u64, u32, u16, u8, i128, i64, i32, i16, i8, usize, isize, bool, char, Symbol
168 | | );
    | | -
    | | |
    | |_any code following this expression is unreachable
    |   in this macro invocation
    |
    = note: this warning originates in the macro `bare_language_child` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unreachable statement
   --> src/lang.rs:221:13
    |
217 | /             panic!(
218 | |                 "(Pond) slotted_egraphs::lang::Bind::from_syntax: expected a single slot, got {:?}",
219 | |                 elems
220 | |             );
    | |_____________- any code following this expression is unreachable
221 |               return None;
    |               ^^^^^^^^^^^^ unreachable statement

warning: unused variable: `v`
  --> src/debug.rs:67:41
   |
67 |                         SyntaxElem::Vec(v) => {
   |                                         ^ help: if this is intentional, prefix it with an underscore: `_v`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: `slotted-egraphs` (lib) generated 19 warnings (14 duplicates)
   Compiling slotted-egraphs v0.0.36 (/home/pondnj/chc/project/slotted-egraphs)
warning: `slotted-egraphs` (lib test) generated 19 warnings (19 duplicates)
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Let(a0, a1))
}, "add" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Add(a0, a1))
}, "mul" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Mul(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: Let(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Rise :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Rise :: Let(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Var :: F(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: F(a0, a1))
}, "g" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: G(a0, a1))
}, "h" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: H(a0, a1))
}
from_syntax_arms1 = "lambda" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Lam(a0))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Var(a0))
}, "sing" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sing(a0, a1))
}, "sum" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind < Bind <
        AppliedId > > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sum(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Lam(a0, a1))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(ArrayLang :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Let(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a2 = tmp ? ; println!
    ("fields: {:?}", a2); children = rest; Some(Fgh :: F(a0, a1, a2))
}, "g" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a2 = tmp ? ; println!
    ("fields: {:?}", a2); children = rest; Some(Fgh :: G(a0, a1, a2))
}, "h" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < Slot > >
        :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Fgh :: H(a0))
}
warning: ambiguous glob re-exports
  --> tests/entry.rs:17:9
   |
17 | pub use fgh::*;
   |         ^^^^^^ the name `Fgh` in the type namespace is first re-exported here
...
26 | pub use chc::*;
   |         ------ but the name `Fgh` in the type namespace is also re-exported here
   |
   = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: unused import: `fgh::*`
  --> tests/entry.rs:17:9
   |
17 | pub use fgh::*;
   |         ^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `chc::*`
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^

warning: `slotted-egraphs` (test "entry") generated 3 warnings (run `cargo fix --test "entry"` to apply 2 suggestions)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.98s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-3e46d232c8c3c10a)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-e549fe6ff08365f6)

running 1 test

s = "(f $1 $2 $3)"
tokenize: ret = [LParen, Ident("f"), Slot($1), Slot($2), Slot($3), RParen]
parse_pattern input tok = [LParen, Ident("f"), Slot($1), Slot($2), Slot($3), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("f"), Slot($1), Slot($2), Slot($3), RParen]
parse_nested_syntax_elem input tok = [Slot($1), Slot($2), Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($1)
parse_nested_syntax_elem input tok = [Slot($2), Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($2)
parse_nested_syntax_elem input tok = [Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($3)
syntax_elems_mock = [String("f"), Slot($1), Slot($2), Slot($3)]
from_syntax::elems = [String("f"), Slot($1), Slot($2), Slot($3)]
children: [Slot($1), Slot($2), Slot($3)]
tmp = Some($1)
fields: $1
tmp = Some($2)
fields: $2
tmp = Some($3)
fields: $3
from_syntax::ret = Some(F($1, $2, $3))
node = Some(F($1, $2, $3))
from_syntax::elems = [String("f"), Slot($1), Slot($2), Slot($3)]
children: [Slot($1), Slot($2), Slot($3)]
tmp = Some($1)
fields: $1
tmp = Some($2)
fields: $2
tmp = Some($3)
fields: $3
from_syntax::ret = Some(F($1, $2, $3))
node = F($1, $2, $3)
syntax_elems = [String("f"), Slot($1), Slot($2), Slot($3)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(F($1, $2, $3), [])
parse_pattern pat_struct = ENode(
    F(
        $1,
        $2,
        $3,
    ),
    [],
), pat_display = (f $1 $2 $3)
RecExpr::parse: ret = ENode(F($1, $2, $3), [])

s = "(g $2 $1 $3)"
tokenize: ret = [LParen, Ident("g"), Slot($2), Slot($1), Slot($3), RParen]
parse_pattern input tok = [LParen, Ident("g"), Slot($2), Slot($1), Slot($3), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("g"), Slot($2), Slot($1), Slot($3), RParen]
parse_nested_syntax_elem input tok = [Slot($2), Slot($1), Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($2)
parse_nested_syntax_elem input tok = [Slot($1), Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($1)
parse_nested_syntax_elem input tok = [Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($3)
syntax_elems_mock = [String("g"), Slot($2), Slot($1), Slot($3)]
from_syntax::elems = [String("g"), Slot($2), Slot($1), Slot($3)]
children: [Slot($2), Slot($1), Slot($3)]
tmp = Some($2)
fields: $2
tmp = Some($1)
fields: $1
tmp = Some($3)
fields: $3
from_syntax::ret = Some(G($2, $1, $3))
node = Some(G($2, $1, $3))
from_syntax::elems = [String("g"), Slot($2), Slot($1), Slot($3)]
children: [Slot($2), Slot($1), Slot($3)]
tmp = Some($2)
fields: $2
tmp = Some($1)
fields: $1
tmp = Some($3)
fields: $3
from_syntax::ret = Some(G($2, $1, $3))
node = G($2, $1, $3)
syntax_elems = [String("g"), Slot($2), Slot($1), Slot($3)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(G($2, $1, $3), [])
parse_pattern pat_struct = ENode(
    G(
        $2,
        $1,
        $3,
    ),
    [],
), pat_display = (g $2 $1 $3)
RecExpr::parse: ret = ENode(G($2, $1, $3), [])

s = "?a"
tokenize: ret = [PVar("a")]
parse_pattern input tok = [PVar("a")]
parse_pattern_nosubst input tok = [PVar("a")]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(g $1 $2 $3)"
tokenize: ret = [LParen, Ident("g"), Slot($1), Slot($2), Slot($3), RParen]
parse_pattern input tok = [LParen, Ident("g"), Slot($1), Slot($2), Slot($3), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("g"), Slot($1), Slot($2), Slot($3), RParen]
parse_nested_syntax_elem input tok = [Slot($1), Slot($2), Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($1)
parse_nested_syntax_elem input tok = [Slot($2), Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($2)
parse_nested_syntax_elem input tok = [Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($3)
syntax_elems_mock = [String("g"), Slot($1), Slot($2), Slot($3)]
from_syntax::elems = [String("g"), Slot($1), Slot($2), Slot($3)]
children: [Slot($1), Slot($2), Slot($3)]
tmp = Some($1)
fields: $1
tmp = Some($2)
fields: $2
tmp = Some($3)
fields: $3
from_syntax::ret = Some(G($1, $2, $3))
node = Some(G($1, $2, $3))
from_syntax::elems = [String("g"), Slot($1), Slot($2), Slot($3)]
children: [Slot($1), Slot($2), Slot($3)]
tmp = Some($1)
fields: $1
tmp = Some($2)
fields: $2
tmp = Some($3)
fields: $3
from_syntax::ret = Some(G($1, $2, $3))
node = G($1, $2, $3)
syntax_elems = [String("g"), Slot($1), Slot($2), Slot($3)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(G($1, $2, $3), [])
parse_pattern pat_struct = ENode(
    G(
        $1,
        $2,
        $3,
    ),
    [],
), pat_display = (g $1 $2 $3)
RecExpr::parse: ret = ENode(G($1, $2, $3), [])

s = "(h <$1 $2 $3>)"
tokenize: ret = [LParen, Ident("h"), LVecBracket, Slot($1), Slot($2), Slot($3), RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("h"), LVecBracket, Slot($1), Slot($2), Slot($3), RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("h"), LVecBracket, Slot($1), Slot($2), Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, Slot($1), Slot($2), Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($1), Slot($2), Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($1)
parse_nested_syntax_elem input tok = [Slot($2), Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($2)
parse_nested_syntax_elem input tok = [Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($3)
syntax_elems_mock = [String("h"), Vec([Slot($1), Slot($2), Slot($3)])]
from_syntax::elems = [String("h"), Vec([Slot($1), Slot($2), Slot($3)])]
children: [Vec([Slot($1), Slot($2), Slot($3)])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($1), Slot($2), Slot($3)])]
tmp = Some([$1, $2, $3])
fields: [$1, $2, $3]
from_syntax::ret = Some(H([$1, $2, $3]))
node = Some(H([$1, $2, $3]))
from_syntax::elems = [String("h"), Vec([Slot($1), Slot($2), Slot($3)])]
children: [Vec([Slot($1), Slot($2), Slot($3)])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($1), Slot($2), Slot($3)])]
tmp = Some([$1, $2, $3])
fields: [$1, $2, $3]
from_syntax::ret = Some(H([$1, $2, $3]))
node = H([$1, $2, $3])
syntax_elems = [String("h"), Vec([Slot($1), Slot($2), Slot($3)])]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(H([$1, $2, $3]), [])
parse_pattern pat_struct = ENode(
    H(
        [
            $1,
            $2,
            $3,
        ],
    ),
    [],
), pat_display = (h $1 $2 $3)
RecExpr::parse: ret = ENode(H([$1, $2, $3]), [])

s = "?a"
tokenize: ret = [PVar("a")]
parse_pattern input tok = [PVar("a")]
parse_pattern_nosubst input tok = [PVar("a")]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b


id1($f3, $f4, $f5):
>> G($f4, $f3, $f5)
 - F($f3, $f4, $f5)
 - H([$f4, $f3, $f5])
 - G($f4, $f3, $f5)


s = "(f $1 $2 $3)"
tokenize: ret = [LParen, Ident("f"), Slot($1), Slot($2), Slot($3), RParen]
parse_pattern input tok = [LParen, Ident("f"), Slot($1), Slot($2), Slot($3), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("f"), Slot($1), Slot($2), Slot($3), RParen]
parse_nested_syntax_elem input tok = [Slot($1), Slot($2), Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($1)
parse_nested_syntax_elem input tok = [Slot($2), Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($2)
parse_nested_syntax_elem input tok = [Slot($3), RParen]
parse_nested_syntax_elem ret = Slot($3)
syntax_elems_mock = [String("f"), Slot($1), Slot($2), Slot($3)]
from_syntax::elems = [String("f"), Slot($1), Slot($2), Slot($3)]
children: [Slot($1), Slot($2), Slot($3)]
tmp = Some($1)
fields: $1
tmp = Some($2)
fields: $2
tmp = Some($3)
fields: $3
from_syntax::ret = Some(F($1, $2, $3))
node = Some(F($1, $2, $3))
from_syntax::elems = [String("f"), Slot($1), Slot($2), Slot($3)]
children: [Slot($1), Slot($2), Slot($3)]
tmp = Some($1)
fields: $1
tmp = Some($2)
fields: $2
tmp = Some($3)
fields: $3
from_syntax::ret = Some(F($1, $2, $3))
node = F($1, $2, $3)
syntax_elems = [String("f"), Slot($1), Slot($2), Slot($3)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(F($1, $2, $3), [])
parse_pattern pat_struct = ENode(
    F(
        $1,
        $2,
        $3,
    ),
    [],
), pat_display = (f $1 $2 $3)
RecExpr::parse: ret = ENode(F($1, $2, $3), [])

s = "(h <$2 $1 $3>)"
tokenize: ret = [LParen, Ident("h"), LVecBracket, Slot($2), Slot($1), Slot($3), RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("h"), LVecBracket, Slot($2), Slot($1), Slot($3), RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("h"), LVecBracket, Slot($2), Slot($1), Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, Slot($2), Slot($1), Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($2), Slot($1), Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($2)
parse_nested_syntax_elem input tok = [Slot($1), Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($1)
parse_nested_syntax_elem input tok = [Slot($3), RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($3)
syntax_elems_mock = [String("h"), Vec([Slot($2), Slot($1), Slot($3)])]
from_syntax::elems = [String("h"), Vec([Slot($2), Slot($1), Slot($3)])]
children: [Vec([Slot($2), Slot($1), Slot($3)])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($2), Slot($1), Slot($3)])]
tmp = Some([$2, $1, $3])
fields: [$2, $1, $3]
from_syntax::ret = Some(H([$2, $1, $3]))
node = Some(H([$2, $1, $3]))
from_syntax::elems = [String("h"), Vec([Slot($2), Slot($1), Slot($3)])]
children: [Vec([Slot($2), Slot($1), Slot($3)])]
vec<L>::from_syntax input elems = []
vec<L>::from_syntax return None1
vec<L>::from_syntax input elems = [Vec([Slot($2), Slot($1), Slot($3)])]
tmp = Some([$2, $1, $3])
fields: [$2, $1, $3]
from_syntax::ret = Some(H([$2, $1, $3]))
node = H([$2, $1, $3])
syntax_elems = [String("h"), Vec([Slot($2), Slot($1), Slot($3)])]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(H([$2, $1, $3]), [])
parse_pattern pat_struct = ENode(
    H(
        [
            $2,
            $1,
            $3,
        ],
    ),
    [],
), pat_display = (h $2 $1 $3)
RecExpr::parse: ret = ENode(H([$2, $1, $3]), [])
test chc::transitive_symmetry ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 70 filtered out; finished in 0.00s


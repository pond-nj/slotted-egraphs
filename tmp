   Compiling slotted-egraphs v0.0.36 (/home/pondnj/chc/project/slotted-egraphs)
warning: unreachable expression
   --> src/lang.rs:121:17
    |
117 | /                 panic!(
118 | |                     "(Pond) slotted_egraphs::lang::AppliedId::from_syntax: expected a single applied id, got {:?}",
119 | |                     elems
120 | |                 );
    | |_________________- any code following this expression is unreachable
121 |                   None
    |                   ^^^^ unreachable expression
    |
    = note: `#[warn(unreachable_code)]` on by default

warning: unreachable expression
   --> src/lang.rs:169:17
    |
165 | /                 panic!(
166 | |                     "(Pond) slotted_egraphs::slot::Slot::from_syntax: expected a single slot, got {:?}",
167 | |                     elems
168 | |                 );
    | |_________________- any code following this expression is unreachable
169 |                   None
    |                   ^^^^ unreachable expression

warning: unreachable expression
   --> src/lang.rs:206:25
    |
206 |                           None
    |                           ^^^^ unreachable expression
...
220 | / bare_language_child!(
221 | |     u128, u64, u32, u16, u8, i128, i64, i32, i16, i8, usize, isize, bool, char, Symbol, String
222 | | );
    | | -
    | | |
    | |_any code following this expression is unreachable
    |   in this macro invocation
    |
    = note: this warning originates in the macro `bare_language_child` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unreachable expression
   --> src/lang.rs:290:17
    |
289 |                 panic!("(Pond) slotted_egraphs::lang::AppliedIdOrStar::from_syntax");
    |                 -------------------------------------------------------------------- any code following this expression is unreachable
290 |                 None
    |                 ^^^^ unreachable expression

warning: unreachable statement
   --> src/lang.rs:355:13
    |
351 | /             panic!(
352 | |                 "(Pond) slotted_egraphs::lang::Bind::from_syntax: expected a single slot, got {:?}",
353 | |                 elems
354 | |             );
    | |_____________- any code following this expression is unreachable
355 |               return None;
    |               ^^^^^^^^^^^^ unreachable statement

warning: unused variable: `v`
  --> src/debug.rs:67:41
   |
67 |                         SyntaxElem::Vec(v) => {
   |                                         ^ help: if this is intentional, prefix it with an underscore: `_v`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: `slotted-egraphs` (lib) generated 21 warnings (15 duplicates)
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "add" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "mul" } }), None, None]
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Let(a0, a1))
}, "add" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Add(a0, a1))
}, "mul" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Mul(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "add" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "mul" } }), return None
v: Variant { attrs: [], ident: Ident { ident: "Number", span: #0 bytes(3934..3940) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "u32", span: #0 bytes(3941..3944) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
v: Variant { attrs: [], ident: Ident { ident: "Symbol", span: #0 bytes(3955..3961) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "Symbol", span: #0 bytes(3962..3968) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
from_syntax_arms2 = if let Some(a) = < u32 > :: from_syntax(elems)
{ return Some(Arith :: Number(a)); }, if let Some(a) = < Symbol > ::
from_syntax(elems) { return Some(Arith :: Symbol(a)); }
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Arith
{
    Lam(Bind < AppliedId >), App(AppliedId, AppliedId), Var(Slot),
    Let(Bind < AppliedId > , AppliedId), Add(AppliedId, AppliedId),
    Mul(AppliedId, AppliedId), Number(u32), Symbol(Symbol),
} impl Language for Arith
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lam"))];
                out.extend(a0.to_syntax()); out
            }, Arith :: App(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("app"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Arith :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, Arith :: Let(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("let"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Arith :: Add(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("add"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Arith :: Mul(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("mul"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Arith :: Number(a0) => { a0.to_syntax() }, Arith :: Symbol(a0)
            => { a0.to_syntax() }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lam" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Arith :: Lam(a0))
            }, "app" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Arith :: App(a0, a1))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Arith :: Var(a0))
            }, "let" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Arith :: Let(a0, a1))
            }, "add" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Arith :: Add(a0, a1))
            }, "mul" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Arith :: Mul(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); if let Some(a) = < u32 >
                :: from_syntax(elems) { return Some(Arith :: Number(a)); } if
                let Some(a) = < Symbol > :: from_syntax(elems)
                { return Some(Arith :: Symbol(a)); } debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Add(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Mul(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Arith :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Arith :: Lam(a0) => { a0.weak_shape_impl(m); }, Arith ::
            App(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Arith :: Var(a0) => { a0.weak_shape_impl(m); }, Arith ::
            Let(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Arith :: Add(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Arith ::
            Mul(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Arith :: Number(a0) => { a0.weak_shape_impl(m); }, Arith ::
            Symbol(a0) => { a0.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Arith :: Lam(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Arith :: App(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Arith :: Var(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Arith :: Let(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Arith :: Add(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Arith :: Mul(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Arith :: Number(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Arith :: Symbol(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } })]
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: Let(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Lambda
{
    Lam(Bind < AppliedId >), App(AppliedId, AppliedId), Var(Slot),
    Let(Bind < AppliedId > , AppliedId),
} impl Language for Lambda
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lam"))];
                out.extend(a0.to_syntax()); out
            }, Lambda :: App(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("app"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Lambda :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, Lambda :: Let(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("let"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lam" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Lambda :: Lam(a0))
            }, "app" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Lambda :: App(a0, a1))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Lambda :: Var(a0))
            }, "let" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Lambda :: Let(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Lambda :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Lambda :: Lam(a0) => { a0.weak_shape_impl(m); }, Lambda ::
            App(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Lambda :: Var(a0) => { a0.weak_shape_impl(m); }, Lambda ::
            Let(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Lambda :: Lam(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Lambda :: App(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Lambda :: Var(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Lambda :: Let(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), None, None]
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Rise :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Rise :: Let(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), return None
v: Variant { attrs: [], ident: Ident { ident: "Number", span: #0 bytes(42642..42648) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "u32", span: #0 bytes(42649..42652) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
v: Variant { attrs: [], ident: Ident { ident: "Symbol", span: #0 bytes(42663..42669) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "Symbol", span: #0 bytes(42670..42676) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
from_syntax_arms2 = if let Some(a) = < u32 > :: from_syntax(elems)
{ return Some(Rise :: Number(a)); }, if let Some(a) = < Symbol > ::
from_syntax(elems) { return Some(Rise :: Symbol(a)); }
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Rise
{
    Lam(Bind < AppliedId >), App(AppliedId, AppliedId), Var(Slot),
    Let(Bind < AppliedId > , AppliedId), Number(u32), Symbol(Symbol),
} impl Language for Rise
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lam"))];
                out.extend(a0.to_syntax()); out
            }, Rise :: App(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("app"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Rise :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, Rise :: Let(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("let"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Rise :: Number(a0) => { a0.to_syntax() }, Rise :: Symbol(a0) =>
            { a0.to_syntax() }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lam" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Rise :: Lam(a0))
            }, "app" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Rise :: App(a0, a1))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Rise :: Var(a0))
            }, "let" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Rise :: Let(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); if let Some(a) = < u32 >
                :: from_syntax(elems) { return Some(Rise :: Number(a)); } if
                let Some(a) = < Symbol > :: from_syntax(elems)
                { return Some(Rise :: Symbol(a)); } debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Rise :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Rise :: Lam(a0) => { a0.weak_shape_impl(m); }, Rise :: App(a0, a1)
            => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Rise ::
            Var(a0) => { a0.weak_shape_impl(m); }, Rise :: Let(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Rise ::
            Number(a0) => { a0.weak_shape_impl(m); }, Rise :: Symbol(a0) =>
            { a0.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Rise :: Lam(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Rise :: App(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Rise :: Var(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Rise :: Let(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Rise :: Number(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Rise :: Symbol(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "f" } })]
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Var :: F(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "f" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Var
{ F(Slot, Slot), } impl Language for Var
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("f"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "f" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; Some(Var :: F(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Var :: F(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Var :: F(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "f" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "g" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "h" } })]
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: F(a0, a1))
}, "g" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: G(a0, a1))
}, "h" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: H(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "f" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "g" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "h" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Fgh
{ F(Slot, Slot), G(Slot, Slot), H(Slot, Slot), } impl Language for Fgh
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("f"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Fgh :: G(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("g"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Fgh :: H(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("h"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "f" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; Some(Fgh :: F(a0, a1))
            }, "g" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; Some(Fgh :: G(a0, a1))
            }, "h" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; Some(Fgh :: H(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: G(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Fgh :: H(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Fgh :: F(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Fgh ::
            G(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            Fgh :: H(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Fgh :: F(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Fgh :: G(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Fgh :: H(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lambda" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "sing" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "sum" } })]
from_syntax_arms1 = "lambda" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Lam(a0))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Var(a0))
}, "sing" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sing(a0, a1))
}, "sum" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind < Bind <
        AppliedId > > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sum(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lambda" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "sing" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "sum" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum Sdql
{
    Lam(Bind < AppliedId >), Var(Slot), Sing(AppliedId, AppliedId),
    Sum(AppliedId, Bind < Bind < AppliedId > >),
} impl Language for Sdql
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lambda"))];
                out.extend(a0.to_syntax()); out
            }, Sdql :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, Sdql :: Sing(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("sing"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, Sdql :: Sum(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("sum"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lambda" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Sdql :: Lam(a0))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(Sdql :: Var(a0))
            }, "sing" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Sdql :: Sing(a0, a1))
            }, "sum" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < Bind < AppliedId > > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(Sdql :: Sum(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sing(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, Sdql :: Sum(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            Sdql :: Lam(a0) => { a0.weak_shape_impl(m); }, Sdql :: Var(a0) =>
            { a0.weak_shape_impl(m); }, Sdql :: Sing(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, Sdql ::
            Sum(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            Sdql :: Lam(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Sdql :: Var(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, Sdql :: Sing(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, Sdql :: Sum(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), None, None]
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Lam(a0, a1))
}, "app" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(ArrayLang :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Let(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "lam" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "app" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "let" } }), return None
v: Variant { attrs: [], ident: Ident { ident: "Number", span: #0 bytes(62930..62936) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "u32", span: #0 bytes(62937..62940) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
v: Variant { attrs: [], ident: Ident { ident: "Symbol", span: #0 bytes(62951..62957) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "Symbol", span: #0 bytes(62958..62964) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
from_syntax_arms2 = if let Some(a) = < u32 > :: from_syntax(elems)
{ return Some(ArrayLang :: Number(a)); }, if let Some(a) = < Symbol > ::
from_syntax(elems) { return Some(ArrayLang :: Symbol(a)); }
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum
ArrayLang
{
    Lam(Slot, AppliedId), App(AppliedId, AppliedId), Var(Slot),
    Let(Bind < AppliedId > , AppliedId), Number(u32), Symbol(Symbol),
} impl Language for ArrayLang
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("lam"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, ArrayLang :: App(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("app"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, ArrayLang :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, ArrayLang :: Let(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("let"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, ArrayLang :: Number(a0) => { a0.to_syntax() }, ArrayLang ::
            Symbol(a0) => { a0.to_syntax() }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "lam" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(ArrayLang :: Lam(a0, a1))
            }, "app" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(ArrayLang :: App(a0, a1))
            }, "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest;
                Some(ArrayLang :: Var(a0))
            }, "let" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Bind
                    < AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(ArrayLang :: Let(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); if let Some(a) = < u32 >
                :: from_syntax(elems) { return Some(ArrayLang :: Number(a)); }
                if let Some(a) = < Symbol > :: from_syntax(elems)
                { return Some(ArrayLang :: Symbol(a)); } debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: App(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Let(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Number(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, ArrayLang :: Symbol(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            ArrayLang :: Lam(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, ArrayLang ::
            App(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            ArrayLang :: Var(a0) => { a0.weak_shape_impl(m); }, ArrayLang ::
            Let(a0, a1) => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); },
            ArrayLang :: Number(a0) => { a0.weak_shape_impl(m); }, ArrayLang
            :: Symbol(a0) => { a0.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            ArrayLang :: Lam(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, ArrayLang :: App(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, ArrayLang :: Var(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, ArrayLang :: Let(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, ArrayLang :: Number(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, ArrayLang :: Symbol(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "and" } })]
from_syntax_arms1 = "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(And :: Var(a0))
}, "and" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec <
        AppliedIdOrStar > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(And :: And(a0, a1))
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "and" } }), return None
from_syntax_arms2 = 
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum And
{ Var(Slot), And(Vec < AppliedIdOrStar > , AppliedId), } impl Language for And
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, And :: And(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("and"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(And :: Var(a0))
            }, "and" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Vec <
                    AppliedIdOrStar > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(And :: And(a0, a1))
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, And :: And(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            And :: Var(a0) => { a0.weak_shape_impl(m); }, And :: And(a0, a1)
            => { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            And :: Var(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, And :: And(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }
        }
    }
}
str_names = [Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "pred" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "new" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "compose" } }), Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "true" } }), None]
from_syntax_arms1 = "var" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Var(a0))
}, "pred" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < Slot > >
        :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; Some(CHC :: PredSyntax(a0, a1))
}, "new" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
    ("fields: {:?}", a1); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a2 = tmp ? ; debug!
    ("fields: {:?}", a2); children = rest; Some(CHC :: New(a0, a1, a2))
}, "compose" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Compose(a0))
}, "true" =>
{
    let mut children = & elems [1 ..]; debug! ("children: {:?}", children);
    let mut rest = children; Some(CHC :: True())
}
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "var" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "pred" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "new" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "compose" } }), return None
produce_from_syntax2: e.is_some(), e=Some(Expr::Lit { attrs: [], lit: Lit::Str { token: "true" } }), return None
v: Variant { attrs: [], ident: Ident { ident: "PredName", span: #0 bytes(66173..66181) }, fields: Fields::Unnamed { paren_token: Paren, unnamed: [Field { attrs: [], vis: Visibility::Inherited, mutability: FieldMutability::None, ident: None, colon_token: None, ty: Type::Path { qself: None, path: Path { leading_colon: None, segments: [PathSegment { ident: Ident { ident: "String", span: #0 bytes(66182..66188) }, arguments: PathArguments::None }] } } }] }, discriminant: None }
from_syntax_arms2 = if let Some(a) = < String > :: from_syntax(elems)
{ return Some(CHC :: PredName(a)); }
trait language #[derive(PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)] pub enum CHC
{
    Var(Slot), PredSyntax(AppliedId, Vec < Slot >),
    New(AppliedId, AppliedId, Vec < AppliedId >), Compose(Vec < AppliedId >),
    True(), PredName(String),
} impl Language for CHC
{
    fn all_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); let out =
                out.chain(a1.all_slot_occurrences_iter_mut()); let out =
                out.chain(a2.all_slot_occurrences_iter_mut()); out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter_mut()); out.collect()
            }
        }
    } fn public_slot_occurrences_mut(& mut self) -> Vec < & mut Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut());
                out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut()); let out =
                out.chain(a1.public_slot_occurrences_iter_mut()); let out =
                out.chain(a2.public_slot_occurrences_iter_mut());
                out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter_mut());
                out.collect()
            }
        }
    } fn applied_id_occurrences_mut(& mut self) -> Vec < & mut AppliedId >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); let out =
                out.chain(a1.applied_id_occurrences_iter_mut()); let out =
                out.chain(a2.applied_id_occurrences_iter_mut()); out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter_mut()); out.collect()
            }
        }
    } fn all_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied()); let out =
                out.chain(a1.all_slot_occurrences_iter().copied()); let out =
                out.chain(a2.all_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.all_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn public_slot_occurrences(& self) -> Vec < Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied()); let
                out = out.chain(a2.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn applied_id_occurrences(& self) -> Vec < & AppliedId >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); let out =
                out.chain(a1.applied_id_occurrences_iter()); let out =
                out.chain(a2.applied_id_occurrences_iter()); out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.applied_id_occurrences_iter()); out.collect()
            }
        }
    } fn to_syntax(& self) -> Vec < SyntaxElem >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("var"))];
                out.extend(a0.to_syntax()); out
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("pred"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax()); out
            }, CHC :: New(a0, a1, a2) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("new"))];
                out.extend(a0.to_syntax()); out.extend(a1.to_syntax());
                out.extend(a2.to_syntax()); out
            }, CHC :: Compose(a0) =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("compose"))];
                out.extend(a0.to_syntax()); out
            }, CHC :: True() =>
            {
                let mut out : Vec < SyntaxElem > = vec!
                [SyntaxElem :: String(String :: from("true"))]; out
            }, CHC :: PredName(a0) => { a0.to_syntax() }
        }
    } fn from_syntax(elems : & [SyntaxElem]) -> Option < Self >
    {
        debug! ("from_syntax::elems = {:?}", elems); let SyntaxElem ::
        String(op) = elems.get(0) ? else { return None }; let ret = match & *
        * op
        {
            "var" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Slot
                    > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; Some(CHC :: Var(a0))
            }, "pred" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Vec <
                    Slot > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest;
                Some(CHC :: PredSyntax(a0, a1))
            }, "new" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; <
                    AppliedId > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a1 = tmp ? ; debug!
                ("fields: {:?}", a1); children = rest; let mut tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Vec <
                    AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a2 = tmp ? ; debug!
                ("fields: {:?}", a2); children = rest;
                Some(CHC :: New(a0, a1, a2))
            }, "compose" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children; let mut
                tmp =
                (0 ..=
                children.len()).filter_map(| n |
                {
                    let a = & children [.. n]; rest = & children [n ..]; < Vec <
                    AppliedId > > :: from_syntax(a)
                }).next(); debug! ("tmp = {:?}", tmp); let a0 = tmp ? ; debug!
                ("fields: {:?}", a0); children = rest;
                Some(CHC :: Compose(a0))
            }, "true" =>
            {
                let mut children = & elems [1 ..]; debug!
                ("children: {:?}", children); let mut rest = children;
                Some(CHC :: True())
            } _ =>
            {
                debug! ("Calling from_syntax_arms2"); if let Some(a) = <
                String > :: from_syntax(elems)
                { return Some(CHC :: PredName(a)); } debug!
                ("L::from_syntax(&elems) = None"); None
            },
        }; debug! ("from_syntax::ret = {:?}", ret); ret
    } fn slots(& self) -> slotted_egraphs :: SmallHashSet < Slot >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: New(a0, a1, a2) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied()); let out
                = out.chain(a1.public_slot_occurrences_iter().copied()); let
                out = out.chain(a2.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: Compose(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }, CHC :: True() =>
            { let out = std :: iter :: empty(); out.collect() }, CHC ::
            PredName(a0) =>
            {
                let out = std :: iter :: empty(); let out =
                out.chain(a0.public_slot_occurrences_iter().copied());
                out.collect()
            }
        }
    } fn weak_shape_inplace(& mut self) -> slotted_egraphs :: SlotMap
    {
        let m = & mut (slotted_egraphs :: SlotMap :: new(), 0); match self
        {
            CHC :: Var(a0) => { a0.weak_shape_impl(m); }, CHC ::
            PredSyntax(a0, a1) =>
            { a0.weak_shape_impl(m); a1.weak_shape_impl(m); }, CHC ::
            New(a0, a1, a2) =>
            {
                a0.weak_shape_impl(m); a1.weak_shape_impl(m);
                a2.weak_shape_impl(m);
            }, CHC :: Compose(a0) => { a0.weak_shape_impl(m); }, CHC :: True()
            => {}, CHC :: PredName(a0) => { a0.weak_shape_impl(m); }
        } m.0.inverse()
    } fn get_children_type(& self) -> Vec < slotted_egraphs ::
    LanguageChildrenType >
    {
        match self
        {
            CHC :: Var(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, CHC :: PredSyntax(a0, a1) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type()); out
            }, CHC :: New(a0, a1, a2) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out.push(a1.get_type());
                out.push(a2.get_type()); out
            }, CHC :: Compose(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }, CHC :: True() =>
            { let mut out : Vec < LanguageChildrenType > = vec! []; out }, CHC
            :: PredName(a0) =>
            {
                let mut out : Vec < LanguageChildrenType > = vec! [];
                out.push(a0.get_type()); out
            }
        }
    }
}
warning: `slotted-egraphs` (lib test) generated 21 warnings (21 duplicates)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.56s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-f989041158719693)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-4ad53240c13203eb)

running 1 test
[slotted_egraphs::parse] 
    s = "(and <?a *> ?b)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [Star, RVecBracket, PVar("b"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("a")), Star])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), Star])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [Star]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), Star])
[entry::chc] fields: [AppliedId(id0, map-[]), Star]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), Star], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), Star], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), Star])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [Star]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), Star])
[entry::chc] fields: [AppliedId(id0, map-[]), Star]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), Star], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), Star], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("a")), Star]), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), Star, PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), Star], id0, map-[]), [PVar("a"), Star, PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                Star,
            ],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            Star,
            PVar(
                "b",
            ),
        ],
    ), pat_display = (and ?a * *)
[slotted_egraphs::parse] 
    s = "(and <?a> ?b)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RVecBracket, PVar("b"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("a"))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("a"))]), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[])], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (and ?a ?b)
[slotted_egraphs::parse] 
    s = "(and <(and <(var $0) (var $1)> (var $3)) (var $2)> (var $3))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($0)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($0)]
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node1 = Some(Var($0))
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node = Var($0)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($0)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($0), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $0,
        ),
        [],
    ), pat_display = (var $0)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($3)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($3)]
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node1 = Some(Var($3))
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node = Var($3)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($3)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($3), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $3,
        ),
        [],
    ), pat_display = (var $3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]), Pattern(ENode(Var($3), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $0,
                ),
                [],
            ),
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            ENode(
                Var(
                    $3,
                ),
                [],
            ),
        ],
    ), pat_display = (and (var $0) (var $1) (var $3))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($2)]
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node1 = Some(Var($2))
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node = Var($2)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($2)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($2), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $2,
        ),
        [],
    ), pat_display = (var $2)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])), Pattern(ENode(Var($2), []))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($3)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($3)]
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node1 = Some(Var($3))
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node = Var($3)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($3)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($3), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $3,
        ),
        [],
    ), pat_display = (var $3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])), Pattern(ENode(Var($2), []))]), Pattern(ENode(Var($3), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            ENode(
                And(
                    [
                        AppliedId(
                            id0, map-[],
                        ),
                        AppliedId(
                            id0, map-[],
                        ),
                    ],
                    id0, map-[],
                ),
                [
                    ENode(
                        Var(
                            $0,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $1,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $3,
                        ),
                        [],
                    ),
                ],
            ),
            ENode(
                Var(
                    $2,
                ),
                [],
            ),
            ENode(
                Var(
                    $3,
                ),
                [],
            ),
        ],
    ), pat_display = (and (and (var $0) (var $1) (var $3)) (var $2) (var $3))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($0), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($1), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($3), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($2), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($3), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::parse] 
    s = "(and <(var $0) (var $1) (var $2)> (var $3))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($0)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($0)]
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node1 = Some(Var($0))
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node = Var($0)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($0)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($0), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $0,
        ),
        [],
    ), pat_display = (var $0)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($2)]
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node1 = Some(Var($2))
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node = Var($2)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($2)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($2), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $2,
        ),
        [],
    ), pat_display = (var $2)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($3)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($3)]
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node1 = Some(Var($3))
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node = Var($3)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($3)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($3), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $3,
        ),
        [],
    ), pat_display = (var $3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))]), Pattern(ENode(Var($3), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $0,
                ),
                [],
            ),
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            ENode(
                Var(
                    $2,
                ),
                [],
            ),
            ENode(
                Var(
                    $3,
                ),
                [],
            ),
        ],
    ), pat_display = (and (var $0) (var $1) (var $2) (var $3))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($0), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($1), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($2), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($3), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])])
ematch_all pattern = ENode(And([AppliedId(id0, map-[]), Star], id0, map-[]), [PVar("a"), Star, PVar("b")])
ematch_impl input pattern = ENode(And([AppliedId(id0, map-[]), Star], id0, map-[]), [PVar("a"), Star, PVar("b")]), st = State { partial_subst: {}, partial_slotmap: [] }, i = id0, map-[$f0 -> $f0]
i eclass = EClass {
    nodes: {
        Var(
            $0,
        ): ProvenSourceNode {
            elem: [$0 -> $f0],
            src_id: id0,
        },
    },
    slots: {
        $f0,
    },
    usages: {
        And(
            [
                AppliedId(
                    id0, map-[$f0 -> $0],
                ),
                AppliedId(
                    id0, map-[$f0 -> $1],
                ),
            ],
            id0, map-[$f0 -> $2],
        ),
        And(
            [
                AppliedId(
                    id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                ),
                AppliedId(
                    id0, map-[$f0 -> $3],
                ),
            ],
            id0, map-[$f0 -> $2],
        ),
    },
    group: Group {
        identity: ProvenPerm {
            elem: [$f0 -> $f0],
        },
        next: None,
    },
    syn_enode: Var(
        $f0,
    ),
    ..
}
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            And(
                [
                    AppliedId(
                        id0, map-[$f0 -> $0],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $1],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ),
            And(
                [
                    AppliedId(
                        id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $3],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
enodes_applied result = [Var($f0)]
ematch_impl enodes in eclass = [Var($f0)]
ematch_impl continue at Discriminant(1) != Discriminant(0)
ematch_impl input pattern = ENode(And([AppliedId(id0, map-[]), Star], id0, map-[]), [PVar("a"), Star, PVar("b")]), st = State { partial_subst: {}, partial_slotmap: [] }, i = id1, map-[$f1 -> $f1, $f2 -> $f2, $f3 -> $f3]
i eclass = EClass {
    nodes: {
        And(
            [
                AppliedId(
                    id0, map-[$f0 -> $0],
                ),
                AppliedId(
                    id0, map-[$f0 -> $1],
                ),
            ],
            id0, map-[$f0 -> $2],
        ): ProvenSourceNode {
            elem: [$0 -> $f1, $1 -> $f2, $2 -> $f3],
            src_id: id1,
        },
    },
    slots: {
        $f1,
        $f2,
        $f3,
    },
    usages: {
        And(
            [
                AppliedId(
                    id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                ),
                AppliedId(
                    id0, map-[$f0 -> $3],
                ),
            ],
            id0, map-[$f0 -> $2],
        ),
    },
    group: Group {
        identity: ProvenPerm {
            elem: [$f1 -> $f1, $f2 -> $f2, $f3 -> $f3],
        },
        next: None,
    },
    syn_enode: And(
        [
            AppliedId(
                id0, map-[$f0 -> $f1],
            ),
            AppliedId(
                id0, map-[$f0 -> $f2],
            ),
        ],
        id0, map-[$f0 -> $f3],
    ),
    ..
}
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2, $f3 -> $f3]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            And(
                [
                    AppliedId(
                        id0, map-[$f0 -> $0],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $1],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2, $2 -> $f3],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
            $f3,
        },
        usages: {
            And(
                [
                    AppliedId(
                        id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $3],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2, $f3 -> $f3],
            },
            next: None,
        },
        syn_enode: And(
            [
                AppliedId(
                    id0, map-[$f0 -> $f1],
                ),
                AppliedId(
                    id0, map-[$f0 -> $f2],
                ),
            ],
            id0, map-[$f0 -> $f3],
        ),
        ..
    }
enodes_applied result = [And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])]
ematch_impl enodes in eclass = [And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])]
clear_n2: And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
n_sh: And([AppliedId(id0, map-[]), Star], id0, map-[])
clear_n2_sh: And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
ematch_impl children_type [Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])] vs [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
ematch_impl match_with_star = true
clear_n2 slots = []
n slots = []
updated partial_slotmap = []
ematch_impl input pattern = PVar("a"), st = State { partial_subst: {}, partial_slotmap: [] }, i = id0, map-[$f0 -> $f1]
i eclass = EClass {
    nodes: {
        Var(
            $0,
        ): ProvenSourceNode {
            elem: [$0 -> $f0],
            src_id: id0,
        },
    },
    slots: {
        $f0,
    },
    usages: {
        And(
            [
                AppliedId(
                    id0, map-[$f0 -> $0],
                ),
                AppliedId(
                    id0, map-[$f0 -> $1],
                ),
            ],
            id0, map-[$f0 -> $2],
        ),
        And(
            [
                AppliedId(
                    id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                ),
                AppliedId(
                    id0, map-[$f0 -> $3],
                ),
            ],
            id0, map-[$f0 -> $2],
        ),
    },
    group: Group {
        identity: ProvenPerm {
            elem: [$f0 -> $f0],
        },
        next: None,
    },
    syn_enode: Var(
        $f0,
    ),
    ..
}
ematch_impl input pattern = Star, st = State { partial_subst: {"a": id0, map-[$f0 -> $f1]}, partial_slotmap: [] }, i = id0, map-[$f0 -> $f2]
i eclass = EClass {
    nodes: {
        Var(
            $0,
        ): ProvenSourceNode {
            elem: [$0 -> $f0],
            src_id: id0,
        },
    },
    slots: {
        $f0,
    },
    usages: {
        And(
            [
                AppliedId(
                    id0, map-[$f0 -> $0],
                ),
                AppliedId(
                    id0, map-[$f0 -> $1],
                ),
            ],
            id0, map-[$f0 -> $2],
        ),
        And(
            [
                AppliedId(
                    id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                ),
                AppliedId(
                    id0, map-[$f0 -> $3],
                ),
            ],
            id0, map-[$f0 -> $2],
        ),
    },
    group: Group {
        identity: ProvenPerm {
            elem: [$f0 -> $f0],
        },
        next: None,
    },
    syn_enode: Var(
        $f0,
    ),
    ..
}

thread 'chc::and' panicked at /home/pondnj/chc/project/slotted-egraphs/src/rewrite/ematch.rs:78:13:
not yet implemented
stack backtrace:
   0: __rustc::rust_begin_unwind
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/panicking.rs:697:5
   1: core::panicking::panic_fmt
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/panicking.rs:75:14
   2: core::panicking::panic
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/panicking.rs:145:5
   3: slotted_egraphs::rewrite::ematch::ematch_impl
             at ./src/rewrite/ematch.rs:78:13
   4: slotted_egraphs::rewrite::ematch::ematch_node
             at ./src/rewrite/ematch.rs:156:29
   5: slotted_egraphs::rewrite::ematch::ematch_impl
             at ./src/rewrite/ematch.rs:72:17
   6: slotted_egraphs::rewrite::ematch::ematch_all
             at ./src/rewrite/ematch.rs:27:13
   7: slotted_egraphs::rewrite::Rewrite<L,N>::new_if::{{closure}}
             at ./src/rewrite/mod.rs:79:42
   8: slotted_egraphs::rewrite::RewriteT<L,N,T>::into::{{closure}}
             at ./src/rewrite/mod.rs:35:51
   9: slotted_egraphs::rewrite::apply_rewrites::{{closure}}
             at ./src/rewrite/mod.rs:53:58
  10: core::iter::adapters::map::map_fold::{{closure}}
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:88:28
  11: <core::slice::iter::Iter<T> as core::iter::traits::iterator::Iterator>::fold
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:255:27
  12: <core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:128:19
  13: core::iter::traits::iterator::Iterator::for_each
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:827:14
  14: alloc::vec::Vec<T,A>::extend_trusted
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3611:26
  15: <alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs:29:14
  16: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter_nested.rs:62:16
  17: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:34:9
  18: <alloc::vec::Vec<T> as core::iter::traits::collect::FromIterator<T>>::from_iter
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3470:9
  19: core::iter::traits::iterator::Iterator::collect
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2027:9
  20: slotted_egraphs::rewrite::apply_rewrites
             at ./src/rewrite/mod.rs:53:78
  21: slotted_egraphs::run::runner::Runner<L,N,IterData,CustomErrorT>::run_one
             at ./src/run/runner.rs:181:24
  22: slotted_egraphs::run::runner::Runner<L,N,IterData,CustomErrorT>::run
             at ./src/run/runner.rs:153:29
  23: entry::assert_reaches
             at ./tests/entry.rs:122:25
  24: entry::chc::and
             at ./tests/chc/mod.rs:67:5
  25: entry::chc::and::{{closure}}
             at ./tests/chc/mod.rs:52:9
  26: core::ops::function::FnOnce::call_once
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
  27: core::ops::function::FnOnce::call_once
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
test chc::and ... FAILED

failures:

failures:
    chc::and

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 70 filtered out; finished in 0.03s

error: test failed, to rerun pass `--test entry`

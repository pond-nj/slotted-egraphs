   Compiling slotted-egraphs v0.0.36 (/home/pondnj/chc/project/slotted-egraphs)
warning: unused variable: `v`
   --> src/parse.rs:194:39
    |
194 |                 NestedSyntaxElem::Vec(v) => todo!(),
    |                                       ^ help: if this is intentional, prefix it with an underscore: `_v`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: `slotted-egraphs` (lib) generated 1 warning
warning: ambiguous glob re-exports
  --> tests/entry.rs:17:9
   |
17 | pub use fgh::*;
   |         ^^^^^^ the name `Fgh` in the type namespace is first re-exported here
...
26 | pub use chc::*;
   |         ------ but the name `Fgh` in the type namespace is also re-exported here
   |
   = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: unused import: `fgh::*`
  --> tests/entry.rs:17:9
   |
17 | pub use fgh::*;
   |         ^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `chc::*`
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^

warning: `slotted-egraphs` (lib test) generated 1 warning (1 duplicate)
warning: `slotted-egraphs` (test "entry") generated 3 warnings (run `cargo fix --test "entry"` to apply 2 suggestions)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.02s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-3e46d232c8c3c10a)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-e549fe6ff08365f6)

running 1 test

s: "(f $1 $2)"
tokenize: ret = [LParen, Ident("f"), Slot($1), Slot($2), RParen]
parse_pattern input tok = [LParen, Ident("f"), Slot($1), Slot($2), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("f"), Slot($1), Slot($2), RParen]
parse_nested_syntax_elem input tok = [Slot($1), Slot($2), RParen]
parse_nested_syntax_elem ret = Slot($1)
parse_nested_syntax_elem input tok = [Slot($2), RParen]
parse_nested_syntax_elem ret = Slot($2)
syntax_elems_mock = [String("f"), Slot($1), Slot($2)]
children: [Slot($1), Slot($2)]
fields: $1
children2: [Slot($2)]
fields: $2
children2: []
node = F($1, $2)
parse_pattern_nosubst ret = ENode(F($1, $2), [])
parse_pattern ret = (
    ENode(
        F(
            $1,
            $2,
        ),
        [],
    ),
    [],
), pat = (f $1 $2)
RecExpr::parse: ret = ENode(F($1, $2), [])

s: "(g $2 $1)"
tokenize: ret = [LParen, Ident("g"), Slot($2), Slot($1), RParen]
parse_pattern input tok = [LParen, Ident("g"), Slot($2), Slot($1), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("g"), Slot($2), Slot($1), RParen]
parse_nested_syntax_elem input tok = [Slot($2), Slot($1), RParen]
parse_nested_syntax_elem ret = Slot($2)
parse_nested_syntax_elem input tok = [Slot($1), RParen]
parse_nested_syntax_elem ret = Slot($1)
syntax_elems_mock = [String("g"), Slot($2), Slot($1)]
children: [Slot($2), Slot($1)]
fields: $2
children2: [Slot($1)]
fields: $1
children2: []
node = G($2, $1)
parse_pattern_nosubst ret = ENode(G($2, $1), [])
parse_pattern ret = (
    ENode(
        G(
            $2,
            $1,
        ),
        [],
    ),
    [],
), pat = (g $2 $1)
RecExpr::parse: ret = ENode(G($2, $1), [])

s: "?a"
tokenize: ret = [PVar("a")]
parse_pattern input tok = [PVar("a")]
parse_pattern_nosubst input tok = [PVar("a")]
parse_pattern_nosubst ret = PVar("a")
parse_pattern ret = (
    PVar(
        "a",
    ),
    [],
), pat = ?a

s: "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret = PVar("b")
parse_pattern ret = (
    PVar(
        "b",
    ),
    [],
), pat = ?b

s: "(g $1 $2)"
tokenize: ret = [LParen, Ident("g"), Slot($1), Slot($2), RParen]
parse_pattern input tok = [LParen, Ident("g"), Slot($1), Slot($2), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("g"), Slot($1), Slot($2), RParen]
parse_nested_syntax_elem input tok = [Slot($1), Slot($2), RParen]
parse_nested_syntax_elem ret = Slot($1)
parse_nested_syntax_elem input tok = [Slot($2), RParen]
parse_nested_syntax_elem ret = Slot($2)
syntax_elems_mock = [String("g"), Slot($1), Slot($2)]
children: [Slot($1), Slot($2)]
fields: $1
children2: [Slot($2)]
fields: $2
children2: []
node = G($1, $2)
parse_pattern_nosubst ret = ENode(G($1, $2), [])
parse_pattern ret = (
    ENode(
        G(
            $1,
            $2,
        ),
        [],
    ),
    [],
), pat = (g $1 $2)
RecExpr::parse: ret = ENode(G($1, $2), [])

s: "(h <$1 $2>)"
tokenize: ret = [LParen, Ident("h"), LVecBracket, Slot($1), Slot($2), RVecBracket, RParen]
parse_pattern input tok = [LParen, Ident("h"), LVecBracket, Slot($1), Slot($2), RVecBracket, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("h"), LVecBracket, Slot($1), Slot($2), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [LVecBracket, Slot($1), Slot($2), RVecBracket, RParen]
parse_nested_syntax_elem input tok = [Slot($1), Slot($2), RVecBracket, RParen]
parse_nested_syntax_elem ret = Slot($1)
parse_nested_syntax_elem input tok = [RVecBracket, RParen]
parse_pattern input tok = [RVecBracket, RParen]
parse_pattern_nosubst input tok = [RVecBracket, RParen]
second case
Error: parse_pattern_nosubst: expected Ident2, got RVecBracket
parse_nested_syntax_elem ret = Err(ParseState([RVecBracket, RParen]))

thread 'chc::transitive_symmetry' panicked at tests/entry.rs:36:32:
called `Result::unwrap()` on an `Err` value: ParseState([RVecBracket, RParen])
stack backtrace:
   0: __rustc::rust_begin_unwind
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/panicking.rs:697:5
   1: core::panicking::panic_fmt
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/panicking.rs:75:14
   2: core::result::unwrap_failed
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/result.rs:1761:5
   3: core::result::Result<T,E>::unwrap
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1167:23
   4: entry::id
             at ./tests/entry.rs:36:32
   5: entry::equate
             at ./tests/entry.rs:51:14
   6: entry::chc::transitive_symmetry
             at ./tests/chc/mod.rs:19:5
   7: entry::chc::transitive_symmetry::{{closure}}
             at ./tests/chc/mod.rs:16:25
   8: core::ops::function::FnOnce::call_once
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
   9: core::ops::function::FnOnce::call_once
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
test chc::transitive_symmetry ... FAILED

failures:

failures:
    chc::transitive_symmetry

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 70 filtered out; finished in 0.01s

error: test failed, to rerun pass `--test entry`

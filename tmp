   Compiling slotted-egraphs v0.0.36 (/home/pondnj/chc/project/slotted-egraphs)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.39s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-6d92e85151c62515)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-44c3f9e1ee7a5866)

running 1 test
[slotted_egraphs::parse] 
    s = "(and <?a *> ?b)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [Star, RVecBracket, PVar("b"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Star, RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("a")), Star])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), Star])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [Star]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), Star])
[entry::chc] fields: [AppliedId(id0, map-[]), Star]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), Star], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), Star], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), Star])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [Star]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), Star])
[entry::chc] fields: [AppliedId(id0, map-[]), Star]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), Star], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), Star], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("a")), Star]), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), Star, PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), Star], id0, map-[]), [PVar("a"), Star, PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                Star,
            ],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            Star,
            PVar(
                "b",
            ),
        ],
    ), pat_display = (and ?a * *)
[slotted_egraphs::parse] 
    s = "(and <?a> ?b)"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("a"), RVecBracket, PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("a")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "a",
    ), pat_display = ?a
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RVecBracket, PVar("b"), RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(PVar("a"))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [PVar("b"), RParen]
[slotted_egraphs::parse] parse_pattern_nosubst ret1 = PVar("b")
[slotted_egraphs::parse] parse_pattern ret pat_struct = PVar(
        "b",
    ), pat_display = ?b
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(PVar("a"))]), Pattern(PVar("b"))]
[slotted_egraphs::parse] transformed syntax_elems = [PVar("a"), PVar("b")]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[])], id0, map-[]), [PVar("a"), PVar("b")])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            PVar(
                "a",
            ),
            PVar(
                "b",
            ),
        ],
    ), pat_display = (and ?a ?b)
[slotted_egraphs::parse] 
    s = "(and <(and <(var $0) (var $1)> (var $3)) (var $2)> (var $3))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($0)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($0)]
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node1 = Some(Var($0))
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node = Var($0)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($0)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($0), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $0,
        ),
        [],
    ), pat_display = (var $0)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($3)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($3)]
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node1 = Some(Var($3))
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node = Var($3)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($3)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($3), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $3,
        ),
        [],
    ), pat_display = (var $3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]), Pattern(ENode(Var($3), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $0,
                ),
                [],
            ),
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            ENode(
                Var(
                    $3,
                ),
                [],
            ),
        ],
    ), pat_display = (and (var $0) (var $1) (var $3))
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($2)]
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node1 = Some(Var($2))
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node = Var($2)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($2)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($2), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $2,
        ),
        [],
    ), pat_display = (var $2)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])), Pattern(ENode(Var($2), []))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($3)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($3)]
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node1 = Some(Var($3))
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node = Var($3)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($3)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($3), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $3,
        ),
        [],
    ), pat_display = (var $3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])), Pattern(ENode(Var($2), []))]), Pattern(ENode(Var($3), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            ENode(
                And(
                    [
                        AppliedId(
                            id0, map-[],
                        ),
                        AppliedId(
                            id0, map-[],
                        ),
                    ],
                    id0, map-[],
                ),
                [
                    ENode(
                        Var(
                            $0,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $1,
                        ),
                        [],
                    ),
                    ENode(
                        Var(
                            $3,
                        ),
                        [],
                    ),
                ],
            ),
            ENode(
                Var(
                    $2,
                ),
                [],
            ),
            ENode(
                Var(
                    $3,
                ),
                [],
            ),
        ],
    ), pat_display = (and (and (var $0) (var $1) (var $3)) (var $2) (var $3))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($0), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($1), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($3), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($2), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($3), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($3), [])]), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::parse] 
    s = "(and <(var $0) (var $1) (var $2)> (var $3))"
[slotted_egraphs::parse] tokenize: ret = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("and"), LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LVecBracket, LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($0)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($0)]
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node1 = Some(Var($0))
[entry::chc] from_syntax::elems = [String("var"), Slot($0)]
[entry::chc] children: [Slot($0)]
[entry::chc] tmp = Some($0)
[entry::chc] fields: $0
[entry::chc] from_syntax::ret = Some(Var($0))
[slotted_egraphs::parse] node = Var($0)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($0)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($0), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $0,
        ),
        [],
    ), pat_display = (var $0)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($1)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($1)]
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node1 = Some(Var($1))
[entry::chc] from_syntax::elems = [String("var"), Slot($1)]
[entry::chc] children: [Slot($1)]
[entry::chc] tmp = Some($1)
[entry::chc] fields: $1
[entry::chc] from_syntax::ret = Some(Var($1))
[slotted_egraphs::parse] node = Var($1)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($1)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($1), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $1,
        ),
        [],
    ), pat_display = (var $1)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($2), RParen, RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($2)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($2)]
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node1 = Some(Var($2))
[entry::chc] from_syntax::elems = [String("var"), Slot($2)]
[entry::chc] children: [Slot($2)]
[entry::chc] tmp = Some($2)
[entry::chc] fields: $2
[entry::chc] from_syntax::ret = Some(Var($2))
[slotted_egraphs::parse] node = Var($2)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($2)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($2), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $2,
        ),
        [],
    ), pat_display = (var $2)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RVecBracket, LParen, Ident("var"), Slot($3), RParen, RParen]))
[slotted_egraphs::parse] parse_nested_syntax_elem ret1 = Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))])
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen]
[slotted_egraphs::parse] parse_nested_syntax_elem ret2 = Slot($3)
[slotted_egraphs::parse] syntax_elems_mock = [String("var"), Slot($3)]
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node1 = Some(Var($3))
[entry::chc] from_syntax::elems = [String("var"), Slot($3)]
[entry::chc] children: [Slot($3)]
[entry::chc] tmp = Some($3)
[entry::chc] fields: $3
[entry::chc] from_syntax::ret = Some(Var($3))
[slotted_egraphs::parse] node = Var($3)
[slotted_egraphs::parse] before syntax_elems = [String("var"), Slot($3)]
[slotted_egraphs::parse] transformed syntax_elems = []
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(Var($3), [])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        Var(
            $3,
        ),
        [],
    ), pat_display = (var $3)
[slotted_egraphs::parse] parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen]))
[slotted_egraphs::parse] syntax_elems_mock = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node1 = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[entry::chc] from_syntax::elems = [String("and"), Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[entry::chc] children: [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::lang] vec<L>::from_syntax input elems = []
[slotted_egraphs::lang] vec<L>::from_syntax return None1
[slotted_egraphs::lang] vec<L>::from_syntax input elems = [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[slotted_egraphs::lang] AppliedIdOrStar::from_syntax, elems: [AppliedId(id0, map-[])]
[entry::chc] tmp = Some([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])])
[entry::chc] fields: [AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
[entry::chc] tmp = Some(id0, map-[])
[entry::chc] fields: id0, map-[]
[entry::chc] from_syntax::ret = Some(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]))
[slotted_egraphs::parse] node = And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::parse] before syntax_elems = [String("and"), Vec([Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))]), Pattern(ENode(Var($3), []))]
[slotted_egraphs::parse] transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])]
[slotted_egraphs::parse] parse_pattern_nosubst ret2 = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::parse] parse_pattern ret pat_struct = ENode(
        And(
            [
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
                AppliedId(
                    id0, map-[],
                ),
            ],
            id0, map-[],
        ),
        [
            ENode(
                Var(
                    $0,
                ),
                [],
            ),
            ENode(
                Var(
                    $1,
                ),
                [],
            ),
            ENode(
                Var(
                    $2,
                ),
                [],
            ),
            ENode(
                Var(
                    $3,
                ),
                [],
            ),
        ],
    ), pat_display = (and (var $0) (var $1) (var $2) (var $3))
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($0), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($1), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($2), [])
[slotted_egraphs::rewrite::pattern] pattern_to_re input pat = ENode(Var($3), [])
[slotted_egraphs::parse] RecExpr::parse: ret = ENode(And([AppliedId(id0, map-[]), AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), []), ENode(Var($2), []), ENode(Var($3), [])])
[slotted_egraphs::rewrite::ematch] ematch_all pattern = ENode(And([AppliedId(id0, map-[]), Star], id0, map-[]), [PVar("a"), Star, PVar("b")])
[slotted_egraphs::rewrite::ematch] ematch_impl(pattern: ENode(And([AppliedId(id0, map-[]), Star], id0, map-[]), [PVar("a"), Star, PVar("b")]),st: State { partial_subst: {}, partial_slotmap: [] },i: id0, map-[$f0 -> $f0],eg: 
    id0($f0):>> Var($f0) - Var($f0)
    id1($f1, $f2, $f3):>> And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3]) - And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])
    id2($f4, $f5, $f6, $f7):>> And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7]) - And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7]))
[slotted_egraphs::egraph] enodes_applied i = id0, map-[$f0 -> $f0]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            Var(
                $0,
            ): ProvenSourceNode {
                elem: [$0 -> $f0],
                src_id: id0,
            },
        },
        slots: {
            $f0,
        },
        usages: {
            And(
                [
                    AppliedId(
                        id0, map-[$f0 -> $0],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $1],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ),
            And(
                [
                    AppliedId(
                        id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $3],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f0 -> $f0],
            },
            next: None,
        },
        syn_enode: Var(
            $f0,
        ),
        ..
    }
enodes_applied result = [Var($f0)]
[slotted_egraphs::rewrite::ematch] ematch_impl enodes in eclass = [Var($f0)]
[slotted_egraphs::rewrite::ematch] ematch_impl continue at Discriminant(1) != Discriminant(0)
[slotted_egraphs::rewrite::ematch] ematch_impl(pattern: ENode(And([AppliedId(id0, map-[]), Star], id0, map-[]), [PVar("a"), Star, PVar("b")]),st: State { partial_subst: {}, partial_slotmap: [] },i: id1, map-[$f1 -> $f1, $f2 -> $f2, $f3 -> $f3],eg: 
    id0($f0):>> Var($f0) - Var($f0)
    id1($f1, $f2, $f3):>> And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3]) - And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])
    id2($f4, $f5, $f6, $f7):>> And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7]) - And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7]))
[slotted_egraphs::egraph] enodes_applied i = id1, map-[$f1 -> $f1, $f2 -> $f2, $f3 -> $f3]
[slotted_egraphs::egraph] classes = EClass {
        nodes: {
            And(
                [
                    AppliedId(
                        id0, map-[$f0 -> $0],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $1],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ): ProvenSourceNode {
                elem: [$0 -> $f1, $1 -> $f2, $2 -> $f3],
                src_id: id1,
            },
        },
        slots: {
            $f1,
            $f2,
            $f3,
        },
        usages: {
            And(
                [
                    AppliedId(
                        id1, map-[$f1 -> $0, $f2 -> $1, $f3 -> $2],
                    ),
                    AppliedId(
                        id0, map-[$f0 -> $3],
                    ),
                ],
                id0, map-[$f0 -> $2],
            ),
        },
        group: Group {
            identity: ProvenPerm {
                elem: [$f1 -> $f1, $f2 -> $f2, $f3 -> $f3],
            },
            next: None,
        },
        syn_enode: And(
            [
                AppliedId(
                    id0, map-[$f0 -> $f1],
                ),
                AppliedId(
                    id0, map-[$f0 -> $f2],
                ),
            ],
            id0, map-[$f0 -> $f3],
        ),
        ..
    }
enodes_applied result = [And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])]
[slotted_egraphs::rewrite::ematch] ematch_impl enodes in eclass = [And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])]
[slotted_egraphs::rewrite::ematch] clear_n2: And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::rewrite::ematch] n_sh: And([AppliedId(id0, map-[]), Star], id0, map-[])
[slotted_egraphs::rewrite::ematch] clear_n2_sh: And([AppliedId(id0, map-[]), AppliedId(id0, map-[])], id0, map-[])
[slotted_egraphs::rewrite::ematch] ematch_node children_type [Vec([AppliedId(id0, map-[]), Star]), AppliedId(id0, map-[])] vs [Vec([AppliedId(id0, map-[]), AppliedId(id0, map-[])]), AppliedId(id0, map-[])]
[slotted_egraphs::rewrite::ematch] ematch_node match_with_star = true
[slotted_egraphs::rewrite::ematch] clear_n2 slots = []
[slotted_egraphs::rewrite::ematch] n slots = []
[slotted_egraphs::rewrite::ematch] updated partial_slotmap = []
[slotted_egraphs::rewrite::ematch] recursing down with ematch_impl with sub_pat = PVar("a"), a = State { partial_subst: {}, partial_slotmap: [] }, sub_id = id0, map-[$f0 -> $f1]
[slotted_egraphs::rewrite::ematch] ematch_impl(pattern: PVar("a"),st: State { partial_subst: {}, partial_slotmap: [] },i: id0, map-[$f0 -> $f1],eg: 
    id0($f0):>> Var($f0) - Var($f0)
    id1($f1, $f2, $f3):>> And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3]) - And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])
    id2($f4, $f5, $f6, $f7):>> And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7]) - And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7]))
[slotted_egraphs::rewrite::ematch] recursing down with ematch_impl with sub_pat = Star, a = State { partial_subst: {"a": id0, map-[$f0 -> $f1]}, partial_slotmap: [] }, sub_id = id0, map-[$f0 -> $f2]
[slotted_egraphs::rewrite::ematch] ematch_impl(pattern: Star,st: State { partial_subst: {"a": id0, map-[$f0 -> $f1]}, partial_slotmap: [] },i: id0, map-[$f0 -> $f2],eg: 
    id0($f0):>> Var($f0) - Var($f0)
    id1($f1, $f2, $f3):>> And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3]) - And([AppliedId(id0, map-[$f0 -> $f1]), AppliedId(id0, map-[$f0 -> $f2])], id0, map-[$f0 -> $f3])
    id2($f4, $f5, $f6, $f7):>> And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7]) - And([AppliedId(id1, map-[$f1 -> $f4, $f2 -> $f5, $f3 -> $f7]), AppliedId(id0, map-[$f0 -> $f6])], id0, map-[$f0 -> $f7]))

thread 'chc::and' panicked at /home/pondnj/chc/project/slotted-egraphs/src/rewrite/ematch.rs:81:13:
not yet implemented
stack backtrace:
   0: __rustc::rust_begin_unwind
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/std/src/panicking.rs:697:5
   1: core::panicking::panic_fmt
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/panicking.rs:75:14
   2: core::panicking::panic
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/panicking.rs:145:5
   3: slotted_egraphs::rewrite::ematch::ematch_impl
             at ./src/rewrite/ematch.rs:81:13
   4: slotted_egraphs::rewrite::ematch::ematch_node
             at ./src/rewrite/ematch.rs:163:29
   5: slotted_egraphs::rewrite::ematch::ematch_impl
             at ./src/rewrite/ematch.rs:75:17
   6: slotted_egraphs::rewrite::ematch::ematch_all
             at ./src/rewrite/ematch.rs:27:13
   7: slotted_egraphs::rewrite::Rewrite<L,N>::new_if::{{closure}}
             at ./src/rewrite/mod.rs:79:42
   8: slotted_egraphs::rewrite::RewriteT<L,N,T>::into::{{closure}}
             at ./src/rewrite/mod.rs:35:51
   9: slotted_egraphs::rewrite::apply_rewrites::{{closure}}
             at ./src/rewrite/mod.rs:53:58
  10: core::iter::adapters::map::map_fold::{{closure}}
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:88:28
  11: <core::slice::iter::Iter<T> as core::iter::traits::iterator::Iterator>::fold
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:255:27
  12: <core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:128:19
  13: core::iter::traits::iterator::Iterator::for_each
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:827:14
  14: alloc::vec::Vec<T,A>::extend_trusted
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3611:26
  15: <alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_extend.rs:29:14
  16: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter_nested.rs:62:16
  17: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:34:9
  18: <alloc::vec::Vec<T> as core::iter::traits::collect::FromIterator<T>>::from_iter
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3470:9
  19: core::iter::traits::iterator::Iterator::collect
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2027:9
  20: slotted_egraphs::rewrite::apply_rewrites
             at ./src/rewrite/mod.rs:53:78
  21: slotted_egraphs::run::runner::Runner<L,N,IterData,CustomErrorT>::run_one
             at ./src/run/runner.rs:181:24
  22: slotted_egraphs::run::runner::Runner<L,N,IterData,CustomErrorT>::run
             at ./src/run/runner.rs:153:29
  23: entry::assert_reaches
             at ./tests/entry.rs:122:25
  24: entry::chc::and
             at ./tests/chc/mod.rs:71:5
  25: entry::chc::and::{{closure}}
             at ./tests/chc/mod.rs:56:9
  26: core::ops::function::FnOnce::call_once
             at /home/pondnj/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
  27: core::ops::function::FnOnce::call_once
             at /rustc/29483883eed69d5fb4db01964cdf2af4d86e9cb2/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
test chc::and ... FAILED

failures:

failures:
    chc::and

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 70 filtered out; finished in 0.03s

error: test failed, to rerun pass `--test entry`

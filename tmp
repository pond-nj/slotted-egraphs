   Compiling memchr v2.7.5
   Compiling futures-sink v0.3.31
   Compiling futures-core v0.3.31
   Compiling pin-project-lite v0.2.16
   Compiling futures-task v0.3.31
   Compiling pin-utils v0.1.0
   Compiling slab v0.4.11
   Compiling scopeguard v1.2.0
   Compiling futures-io v0.3.31
   Compiling parking_lot_core v0.9.11
   Compiling hashbrown v0.14.5
   Compiling log v0.4.28
   Compiling lock_api v0.4.13
   Compiling futures-channel v0.3.31
   Compiling parking_lot v0.12.4
   Compiling futures-util v0.3.31
   Compiling serde_json v1.0.145
   Compiling dashmap v5.5.3
   Compiling tinytemplate v1.2.1
   Compiling criterion v0.5.1
   Compiling futures-executor v0.3.31
   Compiling futures v0.3.31
   Compiling serial_test v1.0.0
   Compiling slotted-egraphs v0.0.36 (/home/pondnj/chc/project/slotted-egraphs)
warning: unreachable expression
  --> src/lang.rs:77:17
   |
73 | /                 panic!(
74 | |                     "(Pond) slotted_egraphs::lang::AppliedId::from_syntax: expected a single applied id, got {:?}",
75 | |                     elems
76 | |                 );
   | |_________________- any code following this expression is unreachable
77 |                   None
   |                   ^^^^ unreachable expression
   |
   = note: `#[warn(unreachable_code)]` on by default

warning: unreachable expression
   --> src/lang.rs:122:17
    |
118 | /                 panic!(
119 | |                     "(Pond) slotted_egraphs::slot::Slot::from_syntax: expected a single slot, got {:?}",
120 | |                     elems
121 | |                 );
    | |_________________- any code following this expression is unreachable
122 |                   None
    |                   ^^^^ unreachable expression

warning: unreachable expression
   --> src/lang.rs:156:25
    |
156 |                           None
    |                           ^^^^ unreachable expression
...
167 | / bare_language_child!(
168 | |     u128, u64, u32, u16, u8, i128, i64, i32, i16, i8, usize, isize, bool, char, Symbol, String
169 | | );
    | | -
    | | |
    | |_any code following this expression is unreachable
    |   in this macro invocation
    |
    = note: this warning originates in the macro `bare_language_child` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unreachable statement
   --> src/lang.rs:222:13
    |
218 | /             panic!(
219 | |                 "(Pond) slotted_egraphs::lang::Bind::from_syntax: expected a single slot, got {:?}",
220 | |                 elems
221 | |             );
    | |_____________- any code following this expression is unreachable
222 |               return None;
    |               ^^^^^^^^^^^^ unreachable statement

warning: unused variable: `v`
  --> src/debug.rs:67:41
   |
67 |                         SyntaxElem::Vec(v) => {
   |                                         ^ help: if this is intentional, prefix it with an underscore: `_v`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: `slotted-egraphs` (lib) generated 20 warnings (15 duplicates)
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Arith :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Let(a0, a1))
}, "add" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Add(a0, a1))
}, "mul" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Arith :: Mul(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Lambda :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Lambda :: Let(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Lam(a0))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Rise :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Rise :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Rise :: Let(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Var :: F(a0, a1))
}
from_syntax_arms1 = "f" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: F(a0, a1))
}, "g" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: G(a0, a1))
}, "h" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Fgh :: H(a0, a1))
}
from_syntax_arms1 = "lambda" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Lam(a0))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(Sdql :: Var(a0))
}, "sing" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sing(a0, a1))
}, "sum" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind < Bind <
        AppliedId > > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(Sdql :: Sum(a0, a1))
}
from_syntax_arms1 = "lam" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Lam(a0, a1))
}, "app" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: App(a0, a1))
}, "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(ArrayLang :: Var(a0))
}, "let" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Bind <
        AppliedId > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(ArrayLang :: Let(a0, a1))
}
from_syntax_arms1 = "var" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Slot > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Var(a0))
}, "pred" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < String > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < Slot > >
        :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; Some(CHC :: Pred(a0, a1))
}, "new" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < AppliedId > ::
        from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a1 = tmp ? ; println!
    ("fields: {:?}", a1); children = rest; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a2 = tmp ? ; println!
    ("fields: {:?}", a2); children = rest; Some(CHC :: New(a0, a1, a2))
}, "compose" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; let mut tmp =
    (0 ..=
    children.len()).filter_map(| n |
    {
        let a = & children [.. n]; rest = & children [n ..]; < Vec < AppliedId
        > > :: from_syntax(a)
    }).next(); println! ("tmp = {:?}", tmp); let a0 = tmp ? ; println!
    ("fields: {:?}", a0); children = rest; Some(CHC :: Compose(a0))
}, "true" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; Some(CHC :: True())
}, "false" =>
{
    let mut children = & elems [1 ..]; println! ("children: {:?}", children);
    let mut rest = children; Some(CHC :: False())
}
warning: ambiguous glob re-exports
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^ the name `get_all_rewrites` in the value namespace is first re-exported here
...
26 | pub use chc::*;
   |         ------ but the name `get_all_rewrites` in the value namespace is also re-exported here
   |
   = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:14:27
   |
14 |     assert_reaches(a, b, &get_all_rewrites()[..], 3);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
   = note: `#[warn(ambiguous_glob_imports)]` on by default

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:28:27
   |
28 |     assert_reaches(a, b, &get_all_rewrites()[..], 2);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:42:27
   |
42 |     assert_reaches(a, b, &get_all_rewrites()[..], 3);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:55:27
   |
55 |     assert_reaches(a, b, &get_all_rewrites()[..], 10);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `get_all_rewrites` is ambiguous
  --> tests/arith/tst.rs:79:27
   |
79 |     assert_reaches(a, b, &get_all_rewrites()[..], 10);
   |                           ^^^^^^^^^^^^^^^^ ambiguous name
   |
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #114095 <https://github.com/rust-lang/rust/issues/114095>
   = note: ambiguous because of multiple glob imports of a name in the same module
note: `get_all_rewrites` could refer to the function imported here
  --> tests/entry.rs:5:9
   |
5  | pub use arith::*;
   |         ^^^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate
note: `get_all_rewrites` could also refer to the function imported here
  --> tests/entry.rs:26:9
   |
26 | pub use chc::*;
   |         ^^^^^^
   = help: consider adding an explicit import of `get_all_rewrites` to disambiguate

warning: `slotted-egraphs` (lib test) generated 20 warnings (20 duplicates)
warning: `slotted-egraphs` (test "entry") generated 6 warnings
    Finished `test` profile [unoptimized + debuginfo] target(s) in 6.75s
     Running unittests src/lib.rs (target/debug/deps/slotted_egraphs-2e28429c01c750e4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 5 filtered out; finished in 0.00s

     Running tests/entry.rs (target/debug/deps/entry-d12e15a0c422f88c)

running 8 tests

s = "(add 2 (mul 2 3))"
tokenize: ret = [LParen, Ident("add"), Ident("2"), LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), Ident("2"), LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), Ident("2"), LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]

s = "a"
parse_nested_syntax_elem input tok = [Ident("2"), LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [Ident("2"), LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]
parse_pattern input tok = [Ident("2"), LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]
tokenize: ret = [Ident("a")]
parse_pattern input tok = [Ident("a")]
parse_pattern_nosubst input tok = [Ident("2"), LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]
second case
from_syntax::elems = [String("2")]
parse_pattern_nosubst input tok = [Ident("a")]
second case
from_syntax::elems = [String("a")]
L(Bare)::from_syntax with elems = [String("2")]
node2 = Some(Number(2))
from_syntax::elems = [String("2")]
L(Bare)::from_syntax with elems = [String("2")]
parse_pattern_nosubst ret3 = ENode(Number(2), [])
parse_pattern pat_struct = ENode(
    Number(
        2,
    ),
    [],
), pat_display = 2
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Number(2), [])), [LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]

s = "(app (lam $1 ?b) ?t)"
L(Bare)::from_syntax with elems = [String("a")]
L(Bare)::from_syntax with elems = [String("a")]
parse_pattern input tok = [LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]
node2 = Some(Symbol("a"))
parse_pattern_nosubst input tok = [LParen, Ident("mul"), Ident("2"), Ident("3"), RParen, RParen]
from_syntax::elems = [String("a")]
tokenize: ret = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Ident("2"), Ident("3"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [Ident("2"), Ident("3"), RParen, RParen]
parse_pattern input tok = [Ident("2"), Ident("3"), RParen, RParen]
parse_pattern_nosubst input tok = [Ident("2"), Ident("3"), RParen, RParen]
L(Bare)::from_syntax with elems = [String("a")]
L(Bare)::from_syntax with elems = [String("a")]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
second case
parse_pattern_nosubst ret3 = ENode(Symbol("a"), [])
parse_pattern pat_struct = ENode(
    Symbol(
        "a",
    ),
    [],
), pat_display = a
pattern_to_re input pat = ENode(Symbol("a"), [])
from_syntax::elems = [String("2")]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("t"), RParen]
L(Bare)::from_syntax with elems = [String("2")]
node2 = Some(Number(2))
from_syntax::elems = [String("2")]
L(Bare)::from_syntax with elems = [String("2")]
parse_pattern_nosubst ret3 = ENode(Number(2), [])
RecExpr::parse: ret = ENode(Symbol("a"), [])
parse_pattern input tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_pattern pat_struct = ENode(
    Number(
        2,
    ),
    [],
), pat_display = 2
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Number(2), [])), [Ident("3"), RParen, RParen]))
parse_nested_syntax_elem input tok = [Ident("3"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [Ident("3"), RParen, RParen]
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("t"), RParen]))
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]

s = "42"
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
parse_pattern input tok = [Ident("3"), RParen, RParen]
parse_pattern_nosubst input tok = [Ident("3"), RParen, RParen]
second case
from_syntax::elems = [String("3")]
L(Bare)::from_syntax with elems = [String("3")]
tokenize: ret = [Ident("42")]
parse_pattern input tok = [Ident("42")]
parse_pattern_nosubst input tok = [Ident("42")]
second case
from_syntax::elems = [String("42")]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
node2 = Some(Number(3))
from_syntax::elems = [String("3")]
L(Bare)::from_syntax with elems = [String("3")]
parse_pattern_nosubst ret3 = ENode(Number(3), [])
parse_pattern pat_struct = ENode(
    Number(
        3,
    ),
    [],
), pat_display = 3
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Number(3), [])), [RParen, RParen]))
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
L(Bare)::from_syntax with elems = [String("42")]
node2 = Some(Number(42))
from_syntax::elems = [String("42")]
L(Bare)::from_syntax with elems = [String("42")]
parse_pattern_nosubst ret3 = ENode(Number(42), [])
before syntax_elems = [String("lam"), Slot($1), Pattern(PVar("b"))]
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
parse_pattern pat_struct = ENode(
    Number(
        42,
    ),
    [],
), pat_display = 42
pattern_to_re input pat = ENode(Number(42), [])
RecExpr::parse: ret = ENode(Number(42), [])
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
transformed syntax_elems = [PVar("b")]

s = "?a"
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
tokenize: ret = [PVar("a")]
parse_pattern input tok = [PVar("a")]
parse_pattern_nosubst input tok = [PVar("a")]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $1 ?b)
node1 = Some(Mul(id0, map-[], id0, map-[]))
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a

s = "?b"
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Number(2), [])), Pattern(ENode(Number(3), []))]

s = "?a"
transformed syntax_elems = [ENode(Number(2), []), ENode(Number(3), [])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Number(3), [])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Number(
                2,
            ),
            [],
        ),
        ENode(
            Number(
                3,
            ),
            [],
        ),
    ],
), pat_display = (mul 2 3)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Number(3), [])])), [RParen]))
tokenize: ret = [PVar("a")]
parse_pattern input tok = [PVar("a")]
parse_pattern_nosubst input tok = [PVar("a")]
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Number(2), [])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Number(3), [])]))]

s = "?b"
tokenize: ret = [PVar("b")]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
transformed syntax_elems = [ENode(Number(2), []), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Number(3), [])])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Number(3), [])])])
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Number(
                2,
            ),
            [],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Number(
                        2,
                    ),
                    [],
                ),
                ENode(
                    Number(
                        3,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (add 2 (mul 2 3))
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Number(3), [])])])
pattern_to_re input pat = ENode(Number(2), [])
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Number(3), [])])
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
pattern_to_re input pat = ENode(Number(2), [])
pattern_to_re input pat = ENode(Number(3), [])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
RecExpr::parse: ret = ENode(Add(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Number(2), []), ENode(Number(3), [])])])
node = App(id0, map-[], id0, map-[])

s = "?a"
tokenize: ret = [PVar("a")]
parse_pattern input tok = [PVar("a")]
parse_pattern_nosubst input tok = [PVar("a")]
parse_pattern_nosubst ret1 = PVar("a")
before syntax_elems = [String("app"), Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("t"))]
test arith::const_prop::const_prop_union ... transformed syntax_elems = [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")])
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a

s = "?b"
tokenize: ret = [PVar("b")]
ok
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (app (lam $1 ?b) ?t)

s = "(let $1 ?b ?t)"
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])

s = "?a"
fields: id0, map-[]
tokenize: ret = [PVar("a")]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
parse_pattern input tok = [PVar("a")]
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
parse_pattern_nosubst input tok = [PVar("a")]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
parse_pattern_nosubst ret1 = PVar("a")
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
tmp = Some(Bind { slot: $1, elem: id0, map-[] })

s = "?b"
fields: Bind { slot: $1, elem: id0, map-[] }
tokenize: ret = [PVar("b")]
tmp = Some(id0, map-[])
parse_pattern input tok = [PVar("b")]
fields: id0, map-[]
parse_pattern_nosubst input tok = [PVar("b")]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
parse_pattern_nosubst ret1 = PVar("b")
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "(lam $1 (app ?b (var $1)))"
tokenize: ret = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)

s = "?a"
fields: $1
tokenize: ret = [PVar("a")]
from_syntax::ret = Some(Var($1))
parse_pattern input tok = [PVar("a")]
node1 = Some(Var($1))
parse_pattern_nosubst input tok = [PVar("a")]
from_syntax::elems = [String("var"), Slot($1)]
parse_pattern_nosubst ret1 = PVar("a")
children: [Slot($1)]
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
tmp = Some($1)

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]

s = "?a"
transformed syntax_elems = []
tokenize: ret = [PVar("a")]
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern input tok = [PVar("a")]
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("b")), Pattern(ENode(Var($1), []))]
parse_pattern_nosubst input tok = [PVar("a")]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
transformed syntax_elems = [PVar("b"), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (app ?b (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])), [RParen]))
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])]))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (lam $1 (app ?b (var $1)))

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]

s = "?a"
tokenize: ret = [PVar("a")]
parse_pattern input tok = [PVar("a")]
parse_pattern_nosubst input tok = [PVar("a")]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "?a"
tokenize: ret = [PVar("a")]
parse_pattern input tok = [PVar("a")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_pattern_nosubst input tok = [PVar("a")]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a

s = "(let $1 ?b ?t)"

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]

s = "8"
tokenize: ret = [Ident("8")]
parse_pattern input tok = [Ident("8")]
parse_pattern_nosubst input tok = [Ident("8")]
second case
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
from_syntax::elems = [String("8")]
L(Bare)::from_syntax with elems = [String("8")]
node2 = Some(Number(8))
from_syntax::elems = [String("8")]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
L(Bare)::from_syntax with elems = [String("8")]
parse_pattern_nosubst ret3 = ENode(Number(8), [])
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
parse_pattern pat_struct = ENode(
    Number(
        8,
    ),
    [],
), pat_display = 8
pattern_to_re input pat = ENode(Number(8), [])
RecExpr::parse: ret = ENode(Number(8), [])
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(let $1 (var $1) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Var($1), [])), Pattern(PVar("e"))]
test arith::const_prop::const_prop ... transformed syntax_elems = [ENode(Var($1), []), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Var($1), []), PVar("e")])
okparse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (var $1) ?e)

s = "?e"

tokenize: ret = [PVar("e")]
parse_pattern input tok = [PVar("e")]
parse_pattern_nosubst input tok = [PVar("e")]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e

s = "(let $1 (app ?a ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (app ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (app ?a ?b) ?e)

s = "(app (let $1 ?a ?e) (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("a")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("a"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?a ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (app (let $1 ?a ?e) (let $1 ?b ?e))

s = "(let $1 (lam $2 ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("b")]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $2 ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $2,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (lam $2 ?b) ?e)

s = "(lam $2 (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (lam $2 (let $1 ?b ?e))

s = "(add ?a ?b)"
tokenize: ret = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)

s = "(add ?b ?a)"
tokenize: ret = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (add ?b ?a)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(mul ?a ?b)"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)

s = "(mul ?b ?a)"
tokenize: ret = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (mul ?b ?a)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(add (var $0) (var $1))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $0,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (add (var $0) (var $1))
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Var($0), [])
pattern_to_re input pat = ENode(Var($1), [])
RecExpr::parse: ret = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])

s = "(add (var $1) (var $0))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($0), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($0), []))]
transformed syntax_elems = [ENode(Var($1), []), ENode(Var($0), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        ENode(
            Var(
                $0,
            ),
            [],
        ),
    ],
), pat_display = (add (var $1) (var $0))
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Var($0), [])
RecExpr::parse: ret = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])
[tests/entry.rs:124:5] &report.stop_reason = Other(
    Reached,
)


id0($f0):
>> Var($f0)
 - Var($f0)

id1($f1, $f2):
>> Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 - Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 -- [$f1 -> $f2, $f2 -> $f1]


s = "(app (lam $1 ?b) ?t)"
tokenize: ret = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
test arith::tst::t1 ... ok
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("t"), RParen]))
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($1), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("b")]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $1 ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("t"))]
transformed syntax_elems = [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (app (lam $1 ?b) ?t)

s = "(let $1 ?b ?t)"
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "(lam $1 (app ?b (var $1)))"
tokenize: ret = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("b")), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [PVar("b"), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (app ?b (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])), [RParen]))
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])]))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (lam $1 (app ?b (var $1)))

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(let $1 ?b ?t)"
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(let $1 (var $1) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Var($1), [])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(Var($1), []), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Var($1), []), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (var $1) ?e)

s = "?e"
tokenize: ret = [PVar("e")]
parse_pattern input tok = [PVar("e")]
parse_pattern_nosubst input tok = [PVar("e")]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e

s = "(let $1 (app ?a ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (app ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (app ?a ?b) ?e)

s = "(app (let $1 ?a ?e) (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("a")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("a"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?a ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (app (let $1 ?a ?e) (let $1 ?b ?e))

s = "(let $1 (lam $2 ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("b")]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $2 ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $2,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (lam $2 ?b) ?e)

s = "(lam $2 (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (lam $2 (let $1 ?b ?e))

s = "(add ?a ?b)"
tokenize: ret = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)

s = "(add ?b ?a)"
tokenize: ret = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (add ?b ?a)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(mul ?a ?b)"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)

s = "(mul ?b ?a)"
tokenize: ret = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (mul ?b ?a)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(mul (add (var $0) (var $1)) (add (var $0) (var $1)))"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $0,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (add (var $0) (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $0,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (add (var $0) (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (mul (add (var $0) (var $1)) (add (var $0) (var $1)))
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Var($0), [])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Var($0), [])
pattern_to_re input pat = ENode(Var($1), [])
RecExpr::parse: ret = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])])

s = "(mul (add (var $0) (var $1)) (add (var $1) (var $0)))"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $0,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (add (var $0) (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($0), []))]
transformed syntax_elems = [ENode(Var($1), []), ENode(Var($0), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        ENode(
            Var(
                $0,
            ),
            [],
        ),
    ],
), pat_display = (add (var $1) (var $0))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])]))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (mul (add (var $0) (var $1)) (add (var $1) (var $0)))
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Var($0), [])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Var($0), [])
RecExpr::parse: ret = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])])
[tests/entry.rs:124:5] &report.stop_reason = Other(
    Reached,
)


id0($f0):
>> Var($f0)
 - Var($f0)

id1($f1, $f2):
>> Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 - Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 -- [$f1 -> $f2, $f2 -> $f1]

id3($f11, $f12):
>> Mul(id1, map-[$f1 -> $f11, $f2 -> $f12], id0, map-[$f0 -> $f11])
 - Mul(id1, map-[$f1 -> $f11, $f2 -> $f12], id0, map-[$f0 -> $f11])

id4($f13, $f14):
>> Add(id3, map-[$f11 -> $f13, $f12 -> $f14], id3, map-[$f11 -> $f14, $f12 -> $f13])
 - Mul(id1, map-[$f1 -> $f13, $f2 -> $f14], id1, map-[$f1 -> $f13, $f2 -> $f14])
 - Add(id3, map-[$f11 -> $f13, $f12 -> $f14], id3, map-[$f11 -> $f14, $f12 -> $f13])
 -- [$f13 -> $f14, $f14 -> $f13]

test arith::tst::t2 ... ok

s = "(app (lam $1 ?b) ?t)"
tokenize: ret = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("t"), RParen]))
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($1), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("b")]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $1 ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("t"))]
transformed syntax_elems = [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (app (lam $1 ?b) ?t)

s = "(let $1 ?b ?t)"
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "(lam $1 (app ?b (var $1)))"
tokenize: ret = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("b")), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [PVar("b"), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (app ?b (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])), [RParen]))
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])]))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (lam $1 (app ?b (var $1)))

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(let $1 ?b ?t)"
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(let $1 (var $1) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Var($1), [])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(Var($1), []), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Var($1), []), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (var $1) ?e)

s = "?e"
tokenize: ret = [PVar("e")]
parse_pattern input tok = [PVar("e")]
parse_pattern_nosubst input tok = [PVar("e")]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e

s = "(let $1 (app ?a ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (app ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (app ?a ?b) ?e)

s = "(app (let $1 ?a ?e) (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("a")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("a"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?a ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (app (let $1 ?a ?e) (let $1 ?b ?e))

s = "(let $1 (lam $2 ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("b")]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $2 ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $2,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (lam $2 ?b) ?e)

s = "(lam $2 (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (lam $2 (let $1 ?b ?e))

s = "(add ?a ?b)"
tokenize: ret = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)

s = "(add ?b ?a)"
tokenize: ret = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (add ?b ?a)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(mul ?a ?b)"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)

s = "(mul ?b ?a)"
tokenize: ret = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (mul ?b ?a)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(mul (add (var $0) (var $1)) (add (var $1) (var $2)))"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $0,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (add (var $0) (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($2), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
syntax_elems_mock = [String("var"), Slot($2)]
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node1 = Some(Var($2))
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Var($2)
before syntax_elems = [String("var"), Slot($2)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($2), [])
parse_pattern pat_struct = ENode(
    Var(
        $2,
    ),
    [],
), pat_display = (var $2)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($2), []))]
transformed syntax_elems = [ENode(Var($1), []), ENode(Var($2), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($2), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        ENode(
            Var(
                $2,
            ),
            [],
        ),
    ],
), pat_display = (add (var $1) (var $2))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($2), [])])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($2), [])]))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($2), [])])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($2), [])])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $2,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (mul (add (var $0) (var $1)) (add (var $1) (var $2)))
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($2), [])])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Var($0), [])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($2), [])])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Var($2), [])
RecExpr::parse: ret = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($2), [])])])

s = "(mul (add (var $2) (var $1)) (add (var $1) (var $0)))"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
syntax_elems_mock = [String("var"), Slot($2)]
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node1 = Some(Var($2))
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Var($2)
before syntax_elems = [String("var"), Slot($2)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($2), [])
parse_pattern pat_struct = ENode(
    Var(
        $2,
    ),
    [],
), pat_display = (var $2)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($2), [])), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [ENode(Var($2), []), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $2,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (add (var $2) (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Var($1), [])])), [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($0), []))]
transformed syntax_elems = [ENode(Var($1), []), ENode(Var($0), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        ENode(
            Var(
                $0,
            ),
            [],
        ),
    ],
), pat_display = (add (var $1) (var $0))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Var($1), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])]))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $2,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (mul (add (var $2) (var $1)) (add (var $1) (var $0)))
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Var($2), [])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Var($0), [])
RecExpr::parse: ret = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Var($1), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])])
[tests/entry.rs:124:5] &report.stop_reason = Other(
    Reached,
)


id0($f0):
>> Var($f0)
 - Var($f0)

id1($f1, $f2):
>> Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 - Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 -- [$f1 -> $f2, $f2 -> $f1]

id3($f14, $f15):
>> Mul(id1, map-[$f1 -> $f15, $f2 -> $f14], id0, map-[$f0 -> $f15])
 - Mul(id1, map-[$f1 -> $f15, $f2 -> $f14], id0, map-[$f0 -> $f15])

id4($f16, $f17, $f18):
>> Mul(id1, map-[$f1 -> $f17, $f2 -> $f16], id0, map-[$f0 -> $f18])
 - Mul(id1, map-[$f1 -> $f16, $f2 -> $f17], id0, map-[$f0 -> $f18])
 -- [$f16 -> $f17, $f17 -> $f16, $f18 -> $f18]

id5($f19, $f20, $f21):
>> Add(id3, map-[$f14 -> $f19, $f15 -> $f20], id4, map-[$f16 -> $f19, $f17 -> $f20, $f18 -> $f21])
 - Add(id3, map-[$f14 -> $f19, $f15 -> $f20], id4, map-[$f16 -> $f19, $f17 -> $f20, $f18 -> $f21])
 - Mul(id1, map-[$f1 -> $f20, $f2 -> $f19], id1, map-[$f1 -> $f20, $f2 -> $f21])
 -- [$f19 -> $f21, $f20 -> $f20, $f21 -> $f19]


s = "(app (lam $1 ?b) ?t)"
tokenize: ret = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
test arith::tst::t3 ... ok
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("t"), RParen]))
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($1), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("b")]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $1 ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("t"))]
transformed syntax_elems = [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (app (lam $1 ?b) ?t)

s = "(let $1 ?b ?t)"
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "(lam $1 (app ?b (var $1)))"
tokenize: ret = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("b")), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [PVar("b"), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (app ?b (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])), [RParen]))
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])]))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (lam $1 (app ?b (var $1)))

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(let $1 ?b ?t)"
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(let $1 (var $1) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Var($1), [])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(Var($1), []), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Var($1), []), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (var $1) ?e)

s = "?e"
tokenize: ret = [PVar("e")]
parse_pattern input tok = [PVar("e")]
parse_pattern_nosubst input tok = [PVar("e")]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e

s = "(let $1 (app ?a ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (app ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (app ?a ?b) ?e)

s = "(app (let $1 ?a ?e) (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("a")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("a"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?a ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (app (let $1 ?a ?e) (let $1 ?b ?e))

s = "(let $1 (lam $2 ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("b")]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $2 ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $2,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (lam $2 ?b) ?e)

s = "(lam $2 (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (lam $2 (let $1 ?b ?e))

s = "(add ?a ?b)"
tokenize: ret = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)

s = "(add ?b ?a)"
tokenize: ret = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (add ?b ?a)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(mul ?a ?b)"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)

s = "(mul ?b ?a)"
tokenize: ret = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (mul ?b ?a)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(add (add (add (add (var $0) (var $1)) (var $2)) (var $3)) (var $4))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $0,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (add (var $0) (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), RParen, RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
syntax_elems_mock = [String("var"), Slot($2)]
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node1 = Some(Var($2))
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Var($2)
before syntax_elems = [String("var"), Slot($2)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($2), [])
parse_pattern pat_struct = ENode(
    Var(
        $2,
    ),
    [],
), pat_display = (var $2)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), Pattern(ENode(Var($2), []))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Var(
                $2,
            ),
            [],
        ),
    ],
), pat_display = (add (add (var $0) (var $1)) (var $2))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])), [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen, LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($3)
syntax_elems_mock = [String("var"), Slot($3)]
from_syntax::elems = [String("var"), Slot($3)]
children: [Slot($3)]
tmp = Some($3)
fields: $3
from_syntax::ret = Some(Var($3))
node1 = Some(Var($3))
from_syntax::elems = [String("var"), Slot($3)]
children: [Slot($3)]
tmp = Some($3)
fields: $3
from_syntax::ret = Some(Var($3))
node = Var($3)
before syntax_elems = [String("var"), Slot($3)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($3), [])
parse_pattern pat_struct = ENode(
    Var(
        $3,
    ),
    [],
), pat_display = (var $3)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen, LParen, Ident("var"), Slot($4), RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])), Pattern(ENode(Var($3), []))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]), ENode(Var($3), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]), ENode(Var($3), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        ENode(
                            Var(
                                $0,
                            ),
                            [],
                        ),
                        ENode(
                            Var(
                                $1,
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    Var(
                        $2,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Var(
                $3,
            ),
            [],
        ),
    ],
), pat_display = (add (add (add (var $0) (var $1)) (var $2)) (var $3))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]), ENode(Var($3), [])])), [LParen, Ident("var"), Slot($4), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($4), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($4), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($4), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($4), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($4)
syntax_elems_mock = [String("var"), Slot($4)]
from_syntax::elems = [String("var"), Slot($4)]
children: [Slot($4)]
tmp = Some($4)
fields: $4
from_syntax::ret = Some(Var($4))
node1 = Some(Var($4))
from_syntax::elems = [String("var"), Slot($4)]
children: [Slot($4)]
tmp = Some($4)
fields: $4
from_syntax::ret = Some(Var($4))
node = Var($4)
before syntax_elems = [String("var"), Slot($4)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($4), [])
parse_pattern pat_struct = ENode(
    Var(
        $4,
    ),
    [],
), pat_display = (var $4)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($4), [])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]), ENode(Var($3), [])])), Pattern(ENode(Var($4), []))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]), ENode(Var($3), [])]), ENode(Var($4), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]), ENode(Var($3), [])]), ENode(Var($4), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        ENode(
                            Add(
                                id0, map-[],
                                id0, map-[],
                            ),
                            [
                                ENode(
                                    Var(
                                        $0,
                                    ),
                                    [],
                                ),
                                ENode(
                                    Var(
                                        $1,
                                    ),
                                    [],
                                ),
                            ],
                        ),
                        ENode(
                            Var(
                                $2,
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    Var(
                        $3,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Var(
                $4,
            ),
            [],
        ),
    ],
), pat_display = (add (add (add (add (var $0) (var $1)) (var $2)) (var $3)) (var $4))
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]), ENode(Var($3), [])]), ENode(Var($4), [])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]), ENode(Var($3), [])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Var($0), [])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Var($2), [])
pattern_to_re input pat = ENode(Var($3), [])
pattern_to_re input pat = ENode(Var($4), [])
RecExpr::parse: ret = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]), ENode(Var($2), [])]), ENode(Var($3), [])]), ENode(Var($4), [])])

s = "(add (add (add (add (var $4) (var $3)) (var $2)) (var $1)) (var $0))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($4), RParen, LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($4)
syntax_elems_mock = [String("var"), Slot($4)]
from_syntax::elems = [String("var"), Slot($4)]
children: [Slot($4)]
tmp = Some($4)
fields: $4
from_syntax::ret = Some(Var($4))
node1 = Some(Var($4))
from_syntax::elems = [String("var"), Slot($4)]
children: [Slot($4)]
tmp = Some($4)
fields: $4
from_syntax::ret = Some(Var($4))
node = Var($4)
before syntax_elems = [String("var"), Slot($4)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($4), [])
parse_pattern pat_struct = ENode(
    Var(
        $4,
    ),
    [],
), pat_display = (var $4)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($4), [])), [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($3), RParen, RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($3)
syntax_elems_mock = [String("var"), Slot($3)]
from_syntax::elems = [String("var"), Slot($3)]
children: [Slot($3)]
tmp = Some($3)
fields: $3
from_syntax::ret = Some(Var($3))
node1 = Some(Var($3))
from_syntax::elems = [String("var"), Slot($3)]
children: [Slot($3)]
tmp = Some($3)
fields: $3
from_syntax::ret = Some(Var($3))
node = Var($3)
before syntax_elems = [String("var"), Slot($3)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($3), [])
parse_pattern pat_struct = ENode(
    Var(
        $3,
    ),
    [],
), pat_display = (var $3)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($3), [])), [RParen, LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($4), [])), Pattern(ENode(Var($3), []))]
transformed syntax_elems = [ENode(Var($4), []), ENode(Var($3), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $4,
            ),
            [],
        ),
        ENode(
            Var(
                $3,
            ),
            [],
        ),
    ],
), pat_display = (add (var $4) (var $3))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])])), [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), RParen, RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
syntax_elems_mock = [String("var"), Slot($2)]
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node1 = Some(Var($2))
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Var($2)
before syntax_elems = [String("var"), Slot($2)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($2), [])
parse_pattern pat_struct = ENode(
    Var(
        $2,
    ),
    [],
), pat_display = (var $2)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [RParen, LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])])), Pattern(ENode(Var($2), []))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $4,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $3,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Var(
                $2,
            ),
            [],
        ),
    ],
), pat_display = (add (add (var $4) (var $3)) (var $2))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])])), [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, LParen, Ident("var"), Slot($0), RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])])), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        ENode(
                            Var(
                                $4,
                            ),
                            [],
                        ),
                        ENode(
                            Var(
                                $3,
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    Var(
                        $2,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (add (add (add (var $4) (var $3)) (var $2)) (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]), ENode(Var($1), [])])), [LParen, Ident("var"), Slot($0), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]), ENode(Var($1), [])])), Pattern(ENode(Var($0), []))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]), ENode(Var($1), [])]), ENode(Var($0), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]), ENode(Var($1), [])]), ENode(Var($0), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        ENode(
                            Add(
                                id0, map-[],
                                id0, map-[],
                            ),
                            [
                                ENode(
                                    Var(
                                        $4,
                                    ),
                                    [],
                                ),
                                ENode(
                                    Var(
                                        $3,
                                    ),
                                    [],
                                ),
                            ],
                        ),
                        ENode(
                            Var(
                                $2,
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Var(
                $0,
            ),
            [],
        ),
    ],
), pat_display = (add (add (add (add (var $4) (var $3)) (var $2)) (var $1)) (var $0))
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]), ENode(Var($1), [])]), ENode(Var($0), [])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])])
pattern_to_re input pat = ENode(Var($4), [])
pattern_to_re input pat = ENode(Var($3), [])
pattern_to_re input pat = ENode(Var($2), [])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Var($0), [])
RecExpr::parse: ret = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($4), []), ENode(Var($3), [])]), ENode(Var($2), [])]), ENode(Var($1), [])]), ENode(Var($0), [])])
[tests/entry.rs:124:5] &report.stop_reason = Other(
    Reached,
)


id0($f0):
>> Var($f0)
 - Var($f0)

id1($f1, $f2):
>> Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 - Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 -- [$f1 -> $f2, $f2 -> $f1]

id2($f3, $f4, $f5):
>> Add(id1, map-[$f1 -> $f3, $f2 -> $f4], id0, map-[$f0 -> $f5])
 - Add(id1, map-[$f1 -> $f4, $f2 -> $f3], id0, map-[$f0 -> $f5])
 - Add(id0, map-[$f0 -> $f5], id1, map-[$f1 -> $f4, $f2 -> $f3])
 -- [$f3 -> $f4, $f4 -> $f3, $f5 -> $f5]
 -- [$f3 -> $f5, $f4 -> $f3, $f5 -> $f4]
 -- [$f3 -> $f3, $f4 -> $f5, $f5 -> $f4]

id3($f6, $f7, $f8, $f9):
>> Add(id2, map-[$f3 -> $f6, $f4 -> $f7, $f5 -> $f8], id0, map-[$f0 -> $f9])
 - Add(id2, map-[$f3 -> $f8, $f4 -> $f6, $f5 -> $f7], id0, map-[$f0 -> $f9])
 - Add(id0, map-[$f0 -> $f9], id2, map-[$f3 -> $f8, $f4 -> $f6, $f5 -> $f7])
 - Add(id1, map-[$f1 -> $f6, $f2 -> $f7], id1, map-[$f1 -> $f9, $f2 -> $f8])
 -- [$f6 -> $f7, $f7 -> $f6, $f8 -> $f8, $f9 -> $f9]
 -- [$f6 -> $f8, $f7 -> $f7, $f8 -> $f6, $f9 -> $f9]
 -- [$f6 -> $f9, $f7 -> $f6, $f8 -> $f7, $f9 -> $f8]
 -- [$f6 -> $f6, $f7 -> $f8, $f8 -> $f7, $f9 -> $f9]
 -- [$f6 -> $f6, $f7 -> $f9, $f8 -> $f8, $f9 -> $f7]
 -- [$f6 -> $f6, $f7 -> $f7, $f8 -> $f9, $f9 -> $f8]

id7($f48, $f49, $f50, $f51, $f52):
>> Add(id0, map-[$f0 -> $f52], id3, map-[$f6 -> $f49, $f7 -> $f48, $f8 -> $f50, $f9 -> $f51])
 - Add(id2, map-[$f3 -> $f49, $f4 -> $f50, $f5 -> $f48], id1, map-[$f1 -> $f52, $f2 -> $f51])
 - Add(id0, map-[$f0 -> $f52], id3, map-[$f6 -> $f49, $f7 -> $f50, $f8 -> $f48, $f9 -> $f51])
 - Add(id3, map-[$f6 -> $f49, $f7 -> $f50, $f8 -> $f48, $f9 -> $f51], id0, map-[$f0 -> $f52])
 -- [$f48 -> $f48, $f49 -> $f49, $f50 -> $f50, $f51 -> $f52, $f52 -> $f51]
 -- [$f48 -> $f48, $f49 -> $f49, $f50 -> $f51, $f51 -> $f52, $f52 -> $f50]
 -- [$f48 -> $f51, $f49 -> $f48, $f50 -> $f50, $f51 -> $f49, $f52 -> $f52]
 -- [$f48 -> $f52, $f49 -> $f49, $f50 -> $f48, $f51 -> $f50, $f52 -> $f51]
 -- [$f48 -> $f50, $f49 -> $f48, $f50 -> $f49, $f51 -> $f51, $f52 -> $f52]
 -- [$f48 -> $f48, $f49 -> $f52, $f50 -> $f50, $f51 -> $f51, $f52 -> $f49]
 -- [$f48 -> $f48, $f49 -> $f51, $f50 -> $f52, $f51 -> $f50, $f52 -> $f49]
 -- [$f48 -> $f48, $f49 -> $f49, $f50 -> $f52, $f51 -> $f51, $f52 -> $f50]
 -- [$f48 -> $f48, $f49 -> $f50, $f50 -> $f52, $f51 -> $f51, $f52 -> $f49]
 -- [$f48 -> $f49, $f49 -> $f48, $f50 -> $f50, $f51 -> $f52, $f52 -> $f51]


s = "(app (lam $1 ?b) ?t)"
tokenize: ret = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), RParen, PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("t"), RParen]
test arith::tst::t5 ... ok
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("t"), RParen]))
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($1), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("b")]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $1 ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("t"))]
transformed syntax_elems = [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [PVar("b")]), PVar("t")])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (app (lam $1 ?b) ?t)

s = "(let $1 ?b ?t)"
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "(lam $1 (app ?b (var $1)))"
tokenize: ret = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("b")), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [PVar("b"), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (app ?b (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])), [RParen]))
syntax_elems_mock = [String("lam"), Slot($1), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($1), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $1, elem: id0, map-[] }))
node = Lam(Bind { slot: $1, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])]))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $1, elem: id0, map-[] }), [ENode(App(id0, map-[], id0, map-[]), [PVar("b"), ENode(Var($1), [])])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (lam $1 (app ?b (var $1)))

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(let $1 ?b ?t)"
tokenize: ret = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("t"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("t"), RParen]
parse_pattern input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("t"), RParen]))
parse_nested_syntax_elem input tok = [PVar("t"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("t"), RParen]
parse_pattern input tok = [PVar("t"), RParen]
parse_pattern_nosubst input tok = [PVar("t"), RParen]
parse_pattern_nosubst ret1 = PVar("t")
parse_pattern pat_struct = PVar(
    "t",
), pat_display = ?t
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("t")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("t"))]
transformed syntax_elems = [PVar("b"), PVar("t")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("t")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "t",
        ),
    ],
), pat_display = (let $1 ?b ?t)

s = "?b"
tokenize: ret = [PVar("b")]
parse_pattern input tok = [PVar("b")]
parse_pattern_nosubst input tok = [PVar("b")]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b

s = "(let $1 (var $1) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Var($1), [])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(Var($1), []), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Var($1), []), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (var $1) ?e)

s = "?e"
tokenize: ret = [PVar("e")]
parse_pattern input tok = [PVar("e")]
parse_pattern_nosubst input tok = [PVar("e")]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e

s = "(let $1 (app ?a ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (app ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(App(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            App(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (app ?a ?b) ?e)

s = "(app (let $1 ?a ?e) (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("app"), LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("a")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("a"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?a ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node1 = Some(App(id0, map-[], id0, map-[]))
from_syntax::elems = [String("app"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(App(id0, map-[], id0, map-[]))
node = App(id0, map-[], id0, map-[])
before syntax_elems = [String("app"), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")])), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(App(id0, map-[], id0, map-[]), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("a"), PVar("e")]), ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    App(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (app (let $1 ?a ?e) (let $1 ?b ?e))

s = "(let $1 (lam $2 ?b) ?e)"
tokenize: ret = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($1), LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem input tok = [Slot($2), PVar("b"), RParen, PVar("e"), RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("e"), RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("b")]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        PVar(
            "b",
        ),
    ],
), pat_display = (lam $2 ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), [PVar("e"), RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen]
parse_pattern input tok = [PVar("e"), RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")])), Pattern(PVar("e"))]
transformed syntax_elems = [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [PVar("b")]), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        ENode(
            Lam(
                Bind {
                    slot: $2,
                    elem: id0, map-[],
                },
            ),
            [
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 (lam $2 ?b) ?e)

s = "(lam $2 (let $1 ?b ?e))"
tokenize: ret = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("lam"), Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
parse_nested_syntax_elem input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("let"), Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), PVar("b"), PVar("e"), RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
parse_nested_syntax_elem input tok = [PVar("b"), PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("e"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("e"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("e"), RParen, RParen]
parse_pattern input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("e"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("e")
parse_pattern pat_struct = PVar(
    "e",
), pat_display = ?e
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("e")), [RParen, RParen]))
syntax_elems_mock = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node1 = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
from_syntax::elems = [String("let"), Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [Slot($1), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $1, elem: id0, map-[] })
fields: Bind { slot: $1, elem: id0, map-[] }
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]))
node = Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[])
before syntax_elems = [String("let"), Slot($1), Pattern(PVar("b")), Pattern(PVar("e"))]
transformed syntax_elems = [PVar("b"), PVar("e")]
parse_pattern_nosubst ret2 = ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])
parse_pattern pat_struct = ENode(
    Let(
        Bind {
            slot: $1,
            elem: id0, map-[],
        },
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "e",
        ),
    ],
), pat_display = (let $1 ?b ?e)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])), [RParen]))
syntax_elems_mock = [String("lam"), Slot($2), AppliedId(id0, map-[])]
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node1 = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
from_syntax::elems = [String("lam"), Slot($2), AppliedId(id0, map-[])]
children: [Slot($2), AppliedId(id0, map-[])]
tmp = Some(Bind { slot: $2, elem: id0, map-[] })
fields: Bind { slot: $2, elem: id0, map-[] }
from_syntax::ret = Some(Lam(Bind { slot: $2, elem: id0, map-[] }))
node = Lam(Bind { slot: $2, elem: id0, map-[] })
before syntax_elems = [String("lam"), Slot($2), Pattern(ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")]))]
transformed syntax_elems = [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])]
parse_pattern_nosubst ret2 = ENode(Lam(Bind { slot: $2, elem: id0, map-[] }), [ENode(Let(Bind { slot: $1, elem: id0, map-[] }, id0, map-[]), [PVar("b"), PVar("e")])])
parse_pattern pat_struct = ENode(
    Lam(
        Bind {
            slot: $2,
            elem: id0, map-[],
        },
    ),
    [
        ENode(
            Let(
                Bind {
                    slot: $1,
                    elem: id0, map-[],
                },
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "e",
                ),
            ],
        ),
    ],
), pat_display = (lam $2 (let $1 ?b ?e))

s = "(add ?a ?b)"
tokenize: ret = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)

s = "(add ?b ?a)"
tokenize: ret = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (add ?b ?a)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add (add ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add (add ?a ?b) ?c)

s = "(add ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add ?a (add ?b ?c))

s = "(mul ?a ?b)"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)

s = "(mul ?b ?a)"
tokenize: ret = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (mul ?b ?a)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul (mul ?a ?b) ?c)"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, PVar("c"), RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [PVar("c"), RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen]
parse_pattern input tok = [PVar("c"), RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(PVar("c"))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul (mul ?a ?b) ?c)

s = "(mul ?a (mul ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Mul(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (mul ?b ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(add (mul ?a ?b) (mul ?a ?c))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen, LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (mul ?a ?b)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("a"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (mul ?a ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")]), ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "b",
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "a",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (add (mul ?a ?b) (mul ?a ?c))

s = "(mul ?a (add ?b ?c))"
tokenize: ret = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("a"), LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("c"), RParen, RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("c"), RParen, RParen]))
parse_nested_syntax_elem input tok = [PVar("c"), RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("c"), RParen, RParen]
parse_pattern input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst input tok = [PVar("c"), RParen, RParen]
parse_pattern_nosubst ret1 = PVar("c")
parse_pattern pat_struct = PVar(
    "c",
), pat_display = ?c
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("c")), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("c"))]
transformed syntax_elems = [PVar("b"), PVar("c")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "c",
        ),
    ],
), pat_display = (add ?b ?c)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(PVar("a")), Pattern(ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")]))]
transformed syntax_elems = [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [PVar("a"), ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("c")])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                PVar(
                    "b",
                ),
                PVar(
                    "c",
                ),
            ],
        ),
    ],
), pat_display = (mul ?a (add ?b ?c))

s = "(mul (add (var $x) (var $y)) (add (var $x) (var $y)))"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($x)
syntax_elems_mock = [String("var"), Slot($x)]
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node1 = Some(Var($x))
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node = Var($x)
before syntax_elems = [String("var"), Slot($x)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($x), [])
parse_pattern pat_struct = ENode(
    Var(
        $x,
    ),
    [],
), pat_display = (var $x)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($y)
syntax_elems_mock = [String("var"), Slot($y)]
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node1 = Some(Var($y))
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node = Var($y)
before syntax_elems = [String("var"), Slot($y)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($y), [])
parse_pattern pat_struct = ENode(
    Var(
        $y,
    ),
    [],
), pat_display = (var $y)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($y), []))]
transformed syntax_elems = [ENode(Var($x), []), ENode(Var($y), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $x,
            ),
            [],
        ),
        ENode(
            Var(
                $y,
            ),
            [],
        ),
    ],
), pat_display = (add (var $x) (var $y))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($x)
syntax_elems_mock = [String("var"), Slot($x)]
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node1 = Some(Var($x))
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node = Var($x)
before syntax_elems = [String("var"), Slot($x)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($x), [])
parse_pattern pat_struct = ENode(
    Var(
        $x,
    ),
    [],
), pat_display = (var $x)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($y)
syntax_elems_mock = [String("var"), Slot($y)]
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node1 = Some(Var($y))
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node = Var($y)
before syntax_elems = [String("var"), Slot($y)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($y), [])
parse_pattern pat_struct = ENode(
    Var(
        $y,
    ),
    [],
), pat_display = (var $y)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($y), []))]
transformed syntax_elems = [ENode(Var($x), []), ENode(Var($y), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $x,
            ),
            [],
        ),
        ENode(
            Var(
                $y,
            ),
            [],
        ),
    ],
), pat_display = (add (var $x) (var $y))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]))]
transformed syntax_elems = [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $x,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $y,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $x,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $y,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (mul (add (var $x) (var $y)) (add (var $x) (var $y)))
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
pattern_to_re input pat = ENode(Var($x), [])
pattern_to_re input pat = ENode(Var($y), [])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
pattern_to_re input pat = ENode(Var($x), [])
pattern_to_re input pat = ENode(Var($y), [])
RecExpr::parse: ret = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])])

s = "(add (mul (var $x) (var $x))\n             (add (mul (var $x) (var $y))\n             (add (mul (var $x) (var $y))\n                  (mul (var $y) (var $y))\n             )))"
tokenize: ret = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($x)
syntax_elems_mock = [String("var"), Slot($x)]
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node1 = Some(Var($x))
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node = Var($x)
before syntax_elems = [String("var"), Slot($x)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($x), [])
parse_pattern pat_struct = ENode(
    Var(
        $x,
    ),
    [],
), pat_display = (var $x)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($x), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($x)
syntax_elems_mock = [String("var"), Slot($x)]
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node1 = Some(Var($x))
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node = Var($x)
before syntax_elems = [String("var"), Slot($x)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($x), [])
parse_pattern pat_struct = ENode(
    Var(
        $x,
    ),
    [],
), pat_display = (var $x)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($x), []))]
transformed syntax_elems = [ENode(Var($x), []), ENode(Var($x), [])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $x,
            ),
            [],
        ),
        ENode(
            Var(
                $x,
            ),
            [],
        ),
    ],
), pat_display = (mul (var $x) (var $x))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])])), [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($x)
syntax_elems_mock = [String("var"), Slot($x)]
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node1 = Some(Var($x))
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node = Var($x)
before syntax_elems = [String("var"), Slot($x)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($x), [])
parse_pattern pat_struct = ENode(
    Var(
        $x,
    ),
    [],
), pat_display = (var $x)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($y)
syntax_elems_mock = [String("var"), Slot($y)]
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node1 = Some(Var($y))
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node = Var($y)
before syntax_elems = [String("var"), Slot($y)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($y), [])
parse_pattern pat_struct = ENode(
    Var(
        $y,
    ),
    [],
), pat_display = (var $y)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($y), []))]
transformed syntax_elems = [ENode(Var($x), []), ENode(Var($y), [])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $x,
            ),
            [],
        ),
        ENode(
            Var(
                $y,
            ),
            [],
        ),
    ],
), pat_display = (mul (var $x) (var $y))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($x), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($x)
syntax_elems_mock = [String("var"), Slot($x)]
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node1 = Some(Var($x))
from_syntax::elems = [String("var"), Slot($x)]
children: [Slot($x)]
tmp = Some($x)
fields: $x
from_syntax::ret = Some(Var($x))
node = Var($x)
before syntax_elems = [String("var"), Slot($x)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($x), [])
parse_pattern pat_struct = ENode(
    Var(
        $x,
    ),
    [],
), pat_display = (var $x)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($x), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($y)
syntax_elems_mock = [String("var"), Slot($y)]
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node1 = Some(Var($y))
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node = Var($y)
before syntax_elems = [String("var"), Slot($y)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($y), [])
parse_pattern pat_struct = ENode(
    Var(
        $y,
    ),
    [],
), pat_display = (var $y)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Var($x), [])), Pattern(ENode(Var($y), []))]
transformed syntax_elems = [ENode(Var($x), []), ENode(Var($y), [])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $x,
            ),
            [],
        ),
        ENode(
            Var(
                $y,
            ),
            [],
        ),
    ],
), pat_display = (mul (var $x) (var $y))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($y), RParen, LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($y)
syntax_elems_mock = [String("var"), Slot($y)]
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node1 = Some(Var($y))
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node = Var($y)
before syntax_elems = [String("var"), Slot($y)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($y), [])
parse_pattern pat_struct = ENode(
    Var(
        $y,
    ),
    [],
), pat_display = (var $y)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($y), RParen, RParen, RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($y)
syntax_elems_mock = [String("var"), Slot($y)]
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node1 = Some(Var($y))
from_syntax::elems = [String("var"), Slot($y)]
children: [Slot($y)]
tmp = Some($y)
fields: $y
from_syntax::ret = Some(Var($y))
node = Var($y)
before syntax_elems = [String("var"), Slot($y)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($y), [])
parse_pattern pat_struct = ENode(
    Var(
        $y,
    ),
    [],
), pat_display = (var $y)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($y), [])), [RParen, RParen, RParen, RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Var($y), [])), Pattern(ENode(Var($y), []))]
transformed syntax_elems = [ENode(Var($y), []), ENode(Var($y), [])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $y,
            ),
            [],
        ),
        ENode(
            Var(
                $y,
            ),
            [],
        ),
    ],
), pat_display = (mul (var $y) (var $y))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])), [RParen, RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $x,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $y,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $y,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $y,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (add (mul (var $x) (var $y)) (mul (var $y) (var $y)))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $x,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $y,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        ENode(
                            Var(
                                $x,
                            ),
                            [],
                        ),
                        ENode(
                            Var(
                                $y,
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        ENode(
                            Var(
                                $y,
                            ),
                            [],
                        ),
                        ENode(
                            Var(
                                $y,
                            ),
                            [],
                        ),
                    ],
                ),
            ],
        ),
    ],
), pat_display = (add (mul (var $x) (var $y)) (add (mul (var $x) (var $y)) (mul (var $y) (var $y))))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])]))]
transformed syntax_elems = [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Mul(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $x,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $x,
                    ),
                    [],
                ),
            ],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Mul(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        ENode(
                            Var(
                                $x,
                            ),
                            [],
                        ),
                        ENode(
                            Var(
                                $y,
                            ),
                            [],
                        ),
                    ],
                ),
                ENode(
                    Add(
                        id0, map-[],
                        id0, map-[],
                    ),
                    [
                        ENode(
                            Mul(
                                id0, map-[],
                                id0, map-[],
                            ),
                            [
                                ENode(
                                    Var(
                                        $x,
                                    ),
                                    [],
                                ),
                                ENode(
                                    Var(
                                        $y,
                                    ),
                                    [],
                                ),
                            ],
                        ),
                        ENode(
                            Mul(
                                id0, map-[],
                                id0, map-[],
                            ),
                            [
                                ENode(
                                    Var(
                                        $y,
                                    ),
                                    [],
                                ),
                                ENode(
                                    Var(
                                        $y,
                                    ),
                                    [],
                                ),
                            ],
                        ),
                    ],
                ),
            ],
        ),
    ],
), pat_display = (add (mul (var $x) (var $x)) (add (mul (var $x) (var $y)) (add (mul (var $x) (var $y)) (mul (var $y) (var $y)))))
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])])
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])])
pattern_to_re input pat = ENode(Var($x), [])
pattern_to_re input pat = ENode(Var($x), [])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
pattern_to_re input pat = ENode(Var($x), [])
pattern_to_re input pat = ENode(Var($y), [])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])])
pattern_to_re input pat = ENode(Var($x), [])
pattern_to_re input pat = ENode(Var($y), [])
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])
pattern_to_re input pat = ENode(Var($y), [])
pattern_to_re input pat = ENode(Var($y), [])
RecExpr::parse: ret = ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($x), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Add(id0, map-[], id0, map-[]), [ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($x), []), ENode(Var($y), [])]), ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($y), []), ENode(Var($y), [])])])])])
[tests/entry.rs:124:5] &report.stop_reason = Other(
    Reached,
)


id0($f0):
>> Var($f0)
 - Var($f0)

id1($f1, $f2):
>> Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 - Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 -- [$f1 -> $f2, $f2 -> $f1]

id3($f11, $f12):
>> Mul(id1, map-[$f1 -> $f11, $f2 -> $f12], id0, map-[$f0 -> $f11])
 - Add(id7, map-[$f75 -> $f11], id6, map-[$f73 -> $f11, $f74 -> $f12])
 - Mul(id0, map-[$f0 -> $f11], id1, map-[$f1 -> $f11, $f2 -> $f12])
 - Mul(id1, map-[$f1 -> $f11, $f2 -> $f12], id0, map-[$f0 -> $f11])
 - Add(id6, map-[$f73 -> $f11, $f74 -> $f12], id7, map-[$f75 -> $f11])

id4($f13, $f14):
>> Add(id3, map-[$f11 -> $f13, $f12 -> $f14], id3, map-[$f11 -> $f14, $f12 -> $f13])
 - Add(id12, map-[$f135 -> $f13, $f136 -> $f14], id7, map-[$f75 -> $f14])
 - Add(id7, map-[$f75 -> $f13], id14, map-[$f139 -> $f13, $f140 -> $f14])
 - Add(id10, map-[$f131 -> $f13, $f132 -> $f14], id6, map-[$f73 -> $f13, $f74 -> $f14])
 - Add(id6, map-[$f73 -> $f13, $f74 -> $f14], id16, map-[$f143 -> $f13, $f144 -> $f14])
 - Mul(id1, map-[$f1 -> $f13, $f2 -> $f14], id1, map-[$f1 -> $f13, $f2 -> $f14])
 - Add(id3, map-[$f11 -> $f13, $f12 -> $f14], id3, map-[$f11 -> $f14, $f12 -> $f13])
 -- [$f13 -> $f14, $f14 -> $f13]

id6($f73, $f74):
>> Mul(id0, map-[$f0 -> $f73], id0, map-[$f0 -> $f74])
 - Mul(id0, map-[$f0 -> $f73], id0, map-[$f0 -> $f74])
 -- [$f73 -> $f74, $f74 -> $f73]

id7($f75):
>> Mul(id0, map-[$f0 -> $f75], id0, map-[$f0 -> $f75])
 - Mul(id0, map-[$f0 -> $f75], id0, map-[$f0 -> $f75])

id10($f131, $f132):
>> Add(id3, map-[$f11 -> $f131, $f12 -> $f132], id7, map-[$f75 -> $f132])
 - Add(id3, map-[$f11 -> $f131, $f12 -> $f132], id7, map-[$f75 -> $f132])

id12($f135, $f136):
>> Add(id3, map-[$f11 -> $f135, $f12 -> $f136], id6, map-[$f73 -> $f136, $f74 -> $f135])
 - Add(id3, map-[$f11 -> $f135, $f12 -> $f136], id6, map-[$f73 -> $f135, $f74 -> $f136])

id14($f139, $f140):
>> Add(id6, map-[$f73 -> $f139, $f74 -> $f140], id3, map-[$f11 -> $f140, $f12 -> $f139])
 - Add(id6, map-[$f73 -> $f140, $f74 -> $f139], id3, map-[$f11 -> $f140, $f12 -> $f139])

id16($f143, $f144):
>> Add(id7, map-[$f75 -> $f143], id3, map-[$f11 -> $f144, $f12 -> $f143])
 - Add(id7, map-[$f75 -> $f143], id3, map-[$f11 -> $f144, $f12 -> $f143])


s = "(add ?a ?b)"
tokenize: ret = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
test arith::tst::t4 ... ok
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("a"), PVar("b"), RParen]
parse_nested_syntax_elem input tok = [PVar("a"), PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), PVar("b"), RParen]
parse_pattern input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [PVar("b"), RParen]))
parse_nested_syntax_elem input tok = [PVar("b"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), RParen]
parse_pattern input tok = [PVar("b"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("a")), Pattern(PVar("b"))]
transformed syntax_elems = [PVar("a"), PVar("b")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("a"), PVar("b")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "a",
        ),
        PVar(
            "b",
        ),
    ],
), pat_display = (add ?a ?b)

s = "(add ?b ?a)"
tokenize: ret = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), PVar("b"), PVar("a"), RParen]
parse_nested_syntax_elem input tok = [PVar("b"), PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("b"), PVar("a"), RParen]
parse_pattern input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("b"), PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("b")
parse_pattern pat_struct = PVar(
    "b",
), pat_display = ?b
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("b")), [PVar("a"), RParen]))
parse_nested_syntax_elem input tok = [PVar("a"), RParen]
Last case in parse_nested_syntax_elem, tok = [PVar("a"), RParen]
parse_pattern input tok = [PVar("a"), RParen]
parse_pattern_nosubst input tok = [PVar("a"), RParen]
parse_pattern_nosubst ret1 = PVar("a")
parse_pattern pat_struct = PVar(
    "a",
), pat_display = ?a
parse_nested_syntax_elem ret3 = Ok((Pattern(PVar("a")), [RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(PVar("b")), Pattern(PVar("a"))]
transformed syntax_elems = [PVar("b"), PVar("a")]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [PVar("b"), PVar("a")])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        PVar(
            "b",
        ),
        PVar(
            "a",
        ),
    ],
), pat_display = (add ?b ?a)

s = "(mul (var $2) (add (var $0) (var $1)))"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
syntax_elems_mock = [String("var"), Slot($2)]
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node1 = Some(Var($2))
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Var($2)
before syntax_elems = [String("var"), Slot($2)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($2), [])
parse_pattern pat_struct = ENode(
    Var(
        $2,
    ),
    [],
), pat_display = (var $2)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($0), [])), Pattern(ENode(Var($1), []))]
transformed syntax_elems = [ENode(Var($0), []), ENode(Var($1), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $0,
            ),
            [],
        ),
        ENode(
            Var(
                $1,
            ),
            [],
        ),
    ],
), pat_display = (add (var $0) (var $1))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Var($2), [])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])]))]
transformed syntax_elems = [ENode(Var($2), []), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $2,
            ),
            [],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (mul (var $2) (add (var $0) (var $1)))
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])])
pattern_to_re input pat = ENode(Var($2), [])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])
pattern_to_re input pat = ENode(Var($0), [])
pattern_to_re input pat = ENode(Var($1), [])
RecExpr::parse: ret = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($0), []), ENode(Var($1), [])])])

s = "(mul (var $2) (add (var $1) (var $0)))"
tokenize: ret = [LParen, Ident("mul"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("mul"), LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($2), RParen, LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($2)
syntax_elems_mock = [String("var"), Slot($2)]
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node1 = Some(Var($2))
from_syntax::elems = [String("var"), Slot($2)]
children: [Slot($2)]
tmp = Some($2)
fields: $2
from_syntax::ret = Some(Var($2))
node = Var($2)
before syntax_elems = [String("var"), Slot($2)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($2), [])
parse_pattern pat_struct = ENode(
    Var(
        $2,
    ),
    [],
), pat_display = (var $2)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($2), [])), [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("add"), LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($1), RParen, LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($1)
syntax_elems_mock = [String("var"), Slot($1)]
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node1 = Some(Var($1))
from_syntax::elems = [String("var"), Slot($1)]
children: [Slot($1)]
tmp = Some($1)
fields: $1
from_syntax::ret = Some(Var($1))
node = Var($1)
before syntax_elems = [String("var"), Slot($1)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($1), [])
parse_pattern pat_struct = ENode(
    Var(
        $1,
    ),
    [],
), pat_display = (var $1)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($1), [])), [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]))
parse_nested_syntax_elem input tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
Last case in parse_nested_syntax_elem, tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern input tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_pattern_nosubst input tok = [LParen, Ident("var"), Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem input tok = [Slot($0), RParen, RParen, RParen]
parse_nested_syntax_elem ret2 = Slot($0)
syntax_elems_mock = [String("var"), Slot($0)]
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node1 = Some(Var($0))
from_syntax::elems = [String("var"), Slot($0)]
children: [Slot($0)]
tmp = Some($0)
fields: $0
from_syntax::ret = Some(Var($0))
node = Var($0)
before syntax_elems = [String("var"), Slot($0)]
transformed syntax_elems = []
parse_pattern_nosubst ret2 = ENode(Var($0), [])
parse_pattern pat_struct = ENode(
    Var(
        $0,
    ),
    [],
), pat_display = (var $0)
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Var($0), [])), [RParen, RParen]))
syntax_elems_mock = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node1 = Some(Add(id0, map-[], id0, map-[]))
from_syntax::elems = [String("add"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Add(id0, map-[], id0, map-[]))
node = Add(id0, map-[], id0, map-[])
before syntax_elems = [String("add"), Pattern(ENode(Var($1), [])), Pattern(ENode(Var($0), []))]
transformed syntax_elems = [ENode(Var($1), []), ENode(Var($0), [])]
parse_pattern_nosubst ret2 = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])
parse_pattern pat_struct = ENode(
    Add(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $1,
            ),
            [],
        ),
        ENode(
            Var(
                $0,
            ),
            [],
        ),
    ],
), pat_display = (add (var $1) (var $0))
parse_nested_syntax_elem ret3 = Ok((Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])), [RParen]))
syntax_elems_mock = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node1 = Some(Mul(id0, map-[], id0, map-[]))
from_syntax::elems = [String("mul"), AppliedId(id0, map-[]), AppliedId(id0, map-[])]
children: [AppliedId(id0, map-[]), AppliedId(id0, map-[])]
tmp = Some(id0, map-[])
fields: id0, map-[]
tmp = Some(id0, map-[])
fields: id0, map-[]
from_syntax::ret = Some(Mul(id0, map-[], id0, map-[]))
node = Mul(id0, map-[], id0, map-[])
before syntax_elems = [String("mul"), Pattern(ENode(Var($2), [])), Pattern(ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])]))]
transformed syntax_elems = [ENode(Var($2), []), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])]
parse_pattern_nosubst ret2 = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])])
parse_pattern pat_struct = ENode(
    Mul(
        id0, map-[],
        id0, map-[],
    ),
    [
        ENode(
            Var(
                $2,
            ),
            [],
        ),
        ENode(
            Add(
                id0, map-[],
                id0, map-[],
            ),
            [
                ENode(
                    Var(
                        $1,
                    ),
                    [],
                ),
                ENode(
                    Var(
                        $0,
                    ),
                    [],
                ),
            ],
        ),
    ],
), pat_display = (mul (var $2) (add (var $1) (var $0)))
pattern_to_re input pat = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])])
pattern_to_re input pat = ENode(Var($2), [])
pattern_to_re input pat = ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])
pattern_to_re input pat = ENode(Var($1), [])
pattern_to_re input pat = ENode(Var($0), [])
RecExpr::parse: ret = ENode(Mul(id0, map-[], id0, map-[]), [ENode(Var($2), []), ENode(Add(id0, map-[], id0, map-[]), [ENode(Var($1), []), ENode(Var($0), [])])])
[tests/entry.rs:124:5] &report.stop_reason = Other(
    Reached,
)


id0($f0):
>> Var($f0)
 - Var($f0)

id1($f1, $f2):
>> Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 - Add(id0, map-[$f0 -> $f1], id0, map-[$f0 -> $f2])
 -- [$f1 -> $f2, $f2 -> $f1]

id2($f3, $f4, $f5):
>> Mul(id0, map-[$f0 -> $f5], id1, map-[$f1 -> $f3, $f2 -> $f4])
 - Mul(id0, map-[$f0 -> $f5], id1, map-[$f1 -> $f4, $f2 -> $f3])
 -- [$f3 -> $f4, $f4 -> $f3, $f5 -> $f5]

test arith::tst::t6 ... ok

test result: ok. 8 passed; 0 failed; 0 ignored; 0 measured; 63 filtered out; finished in 0.05s

